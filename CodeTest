library(sf)
library(spdep)
library(whitebox)
library(car)

###Section 1 - Data preparation and variable calculation
#Upload and prepare data file
Dados_SpatialCorkOak_9_maio_l23 <- read_excel("C:/Users/caven/Google Drive (paulofirmino@e-isa.ulisboa.pt)/2023-Doutoramento/SpatialCorkoak/Dados_SpatialCorkOak_9_maio_l23.xlsx")
Dados_SpatialCorkOak1A<-Dados_SpatialCorkOak1[which(Dados_SpatialCorkOak1$Site == "A"),] ## Select on of the 4 properties (A, B, C, D)
Dados_SpatialCorkOak1A<-Dados_SpatialCorkOak1A[which(Dados_SpatialCorkOak1A$mais_velha == 0),]  ##Remove clearly older trees present in the plantation area

#1.1 Geographical position indices calculation (TPI and TRI)
f <- matrix(1, nrow=5, ncol=5)
TPI_focal <- focal(Altimetria, w=f, fun=function(x, ...) x[5] - mean(x[-5]), pad=TRUE, padValue=NA)
plot(TPI_focal)
TRI <- focal(Altimetria, w=f, fun=function(x) sum(abs(x[-5]-x[5]))/8, pad=TRUE, padValue=NA)
plot(TRI)

#1.2 Geographical position indices calculation (TWI)
# TWI calculation based on the methodology of https://vt-hydroinformatics.github.io/rgeoraster.html

  # Prepare DEM for Hydrology Analyses
  wbt_breach_depressions_least_cost(
  dem = "C:/Users/caven/Google Drive (paulofirmino@e-isa.ulisboa.pt)/2022-Doutoramento/SpatialCorkoak Paper/CasteloBranco/Novos Dados/Orvalho_Altimetria.tif",
  output = "C:/Users/caven/Google Drive (paulofirmino@e-isa.ulisboa.pt)/2022-Doutoramento/SpatialCorkoak Paper/CasteloBranco/Novos Dados/Teste/VO_DTM_breach.tif",
  dist = 5,
  fill = TRUE)

  # wbt_fill_depressions_wang_and_liu(
  dem = "C:/Users/caven/Google Drive (paulofirmino@e-isa.ulisboa.pt)/2022-Doutoramento/SpatialCorkoak Paper/CasteloBranco/Novos Dados/Teste/VO_DTM_breach.tif",
  output = "C:/Users/caven/Google Drive (paulofirmino@e-isa.ulisboa.pt)/2022-Doutoramento/SpatialCorkoak Paper/CasteloBranco/Novos Dados/Teste/VO_DTM_breach_fill.tif",
  )
  # Visualize and correct filled sinks and breached depression
  filled_breached <- raster("C:/Users/caven/Google Drive (paulofirmino@e-isa.ulisboa.pt)/2022-Doutoramento/SpatialCorkoak Paper/CasteloBranco/Novos Dados/Teste/VO_DTM_breach_fill.tif")
  plot(filled_breached)
    difference <- Altimetria - filled_breached
  difference[difference == 0] <- NA

  #D infinity flow accumulation (alternative flow accumulation may be calculated from D infinity method D8 Flow Accumulation)
  wbt_d_inf_flow_accumulation("C:/Users/caven/Google Drive (paulofirmino@e-isa.ulisboa.pt)/2022-Doutoramento/SpatialCorkoak Paper/CasteloBranco/Novos Dados/Teste/VO_DTM_breach_fill.tif",
                              "C:/Users/caven/Google Drive (paulofirmino@e-isa.ulisboa.pt)/2022-Doutoramento/SpatialCorkoak Paper/CasteloBranco/Novos Dados/Teste/Infinit_FlowAccum.tif")
  dinf <- raster("C:/Users/caven/Google Drive (paulofirmino@e-isa.ulisboa.pt)/2022-Doutoramento/SpatialCorkoak Paper/CasteloBranco/Novos Dados/Teste/Infinit_FlowAccum.tif")
  plot(dinf)

  #Calculate Specific Contributing Area
  wbt_d_inf_flow_accumulation(input = "C:/Users/caven/Google Drive (paulofirmino@e-isa.ulisboa.pt)/2022-Doutoramento/SpatialCorkoak Paper/CasteloBranco/Novos Dados/Teste/VO_DTM_breach_fill.tif",
                            output = "C:/Users/caven/Google Drive (paulofirmino@e-isa.ulisboa.pt)/2022-Doutoramento/SpatialCorkoak Paper/CasteloBranco/Novos Dados/Teste/FlowAccum2.tif",
                            out_type = "Specific Contributing Area")

  #Calculate slope or use slope mapped tif from data
  wbt_slope(dem = "C:/Users/caven/Google Drive (paulofirmino@e-isa.ulisboa.pt)/2022-Doutoramento/SpatialCorkoak Paper/CasteloBranco/Novos Dados/Teste/VO_DTM_breach_fill.tif",
          output = "C:/Users/caven/Google Drive (paulofirmino@e-isa.ulisboa.pt)/2022-Doutoramento/SpatialCorkoak Paper/CasteloBranco/Novos Dados/Teste/VO_slope_degrees.tif",
          units = "degrees")
  #Calculate topographic wetness index
  wbt_wetness_index(sca = "C:/Users/caven/Google Drive (paulofirmino@e-isa.ulisboa.pt)/2022-Doutoramento/SpatialCorkoak Paper/CasteloBranco/Novos Dados/Teste/FlowAccum2.tif",
                  slope = "C:/Users/caven/Google Drive (paulofirmino@e-isa.ulisboa.pt)/2022-Doutoramento/SpatialCorkoak Paper/CasteloBranco/Novos Dados/Teste/VO_slope_degrees.tif",
                  output = "C:/Users/caven/Google Drive (paulofirmino@e-isa.ulisboa.pt)/2022-Doutoramento/SpatialCorkoak Paper/CasteloBranco/Novos Dados/Teste/TWI.tif")

  twi <- raster("C:/Users/caven/Google Drive (paulofirmino@e-isa.ulisboa.pt)/2022-Doutoramento/SpatialCorkoak Paper/CasteloBranco/Novos Dados/Teste/TWI.tif")
  plot(twi)

#######################################
#Calculate dimaeter related variables and attribute explanatory values to points

#Considering du response variable

#Attribute exploratory variable value according to the pixel where tree is positioned
Mach_dados1$Cea_1m_1px<-extract(Cea_1m,Mach_dados1) #Variable Example


#######################################
#Considering du_mean response variable

##### Creating variables considering a moving window of the subject tree and the 8 closer neighbours (queen's case continuity)

#Remove lines with NA's in TRI/TPI, respective to points very close to the limits of the area and the 5x5 matrix from TRI is not completetly available
Mach_dados1 <- Mach_dados1[!is.na(Mach_dados1$TRI_1px), ]  

#Calculation of du_mean and attribution of values to tree points

#Creating a dataframe for each subject tree and respective closest 8 neighbours (queen case)
valor_du_mixid <- data.frame(matrix(NA,  ncol = 39))
valor_du_mix1 <- data.frame(matrix(NA,  ncol = 39))
valor_du_mix2 <- data.frame(matrix(NA,  ncol = 39))
valor_du_mix3 <- data.frame(matrix(NA,  ncol = 39))
valor_du_mix4 <- data.frame(matrix(NA,  ncol = 39))
valor_du_mix5 <- data.frame(matrix(NA,  ncol = 39))
valor_du_mix6 <- data.frame(matrix(NA,  ncol = 39))
valor_du_mix7 <- data.frame(matrix(NA,  ncol = 39))
valor_du_mix8 <- data.frame(matrix(NA,  ncol = 39))

#Find each subject tree and respective closest 8 neighbours (queen case)
Mach_dados1$continId<-c(1:dim(Mach_dados1)[1])
for(i in c(1:nrow(Mach_dados1))) {
  valor_du_mixid[i,]<-Mach_dados1[i,]
  valor_du_mix1[i,]<-(Mach_dados1[which(Mach_dados1$continId == ((knearneigh(Mach_dados1, k=8)$nn[i]))),])
  valor_du_mix2[i,]<-(Mach_dados1[which(Mach_dados1$continId == ((knearneigh(Mach_dados1, k=8)$nn[i,2]))),])
  valor_du_mix3[i,]<-(Mach_dados1[which(Mach_dados1$continId == ((knearneigh(Mach_dados1, k=8)$nn[i,3]))),])
  valor_du_mix4[i,]<-(Mach_dados1[which(Mach_dados1$continId == ((knearneigh(Mach_dados1, k=8)$nn[i,4]))),])
  valor_du_mix5[i,]<-(Mach_dados1[which(Mach_dados1$continId == ((knearneigh(Mach_dados1, k=8)$nn[i,5]))),])
  valor_du_mix6[i,]<-(Mach_dados1[which(Mach_dados1$continId == ((knearneigh(Mach_dados1, k=8)$nn[i,6]))),])
  valor_du_mix7[i,]<-(Mach_dados1[which(Mach_dados1$continId == ((knearneigh(Mach_dados1, k=8)$nn[i,7]))),])
  valor_du_mix8[i,]<-(Mach_dados1[which(Mach_dados1$continId == ((knearneigh(Mach_dados1, k=8)$nn[i,8]))),])
}
head(valor_du_mixid)
colnames(valor_du_mixid)<-names(Mach_dados1)
colnames(valor_du_mix1)<-names(Mach_dados1)
colnames(valor_du_mix2)<-names(Mach_dados1)
colnames(valor_du_mix3)<-names(Mach_dados1)
colnames(valor_du_mix4)<-names(Mach_dados1)
colnames(valor_du_mix5)<-names(Mach_dados1)
colnames(valor_du_mix6)<-names(Mach_dados1)
colnames(valor_du_mix7)<-names(Mach_dados1)
colnames(valor_du_mix8)<-names(Mach_dados1)

#Calculate mean_du
names(Mach_dados1)
Mach_dados1$mean_du_mix<-((valor_du_mixid[,"Du2021"]+valor_du_mix1[,"Du2021"]+valor_du_mix2[,"Du2021"]+valor_du_mix3[,"Du2021"]+
                           valor_du_mix4[,"Du2021"]+valor_du_mix5[,"Du2021"]+valor_du_mix6[,"Du2021"]+valor_du_mix7[,"Du2021"]+
                           valor_du_mix8[,"Du2021"])/9)
plot(Mach_dados1["mean_du_mix"], pch=16)

#Calculate values of terrain variables attributes to points
Mach_dados1$Cea_0.5_mix<-((valor_du_mixid[,"Cea_0.5m_1px"]+valor_du_mix1[,"Cea_0.5m_1px"]+valor_du_mix2[,"Cea_0.5m_1px"]+valor_du_mix3[,"Cea_0.5m_1px"]+  #Example of Cea_0.5
                           valor_du_mix4[,"Cea_0.5m_1px"]+valor_du_mix5[,"Cea_0.5m_1px"]+valor_du_mix6[,"Cea_0.5m_1px"]+valor_du_mix7[,"Cea_0.5m_1px"]+
                           valor_du_mix8[,"Cea_0.5m_1px"])/9)

#######################################
#Spatial autocorrelation analysis
#Definition of Spatial Matrix
#Selection of neighbours according to overlapping areas of influence

Mach_dados2$du_dug<-""
Mach_dados2$du_dug<-Mach_dados2$Du2021/(sqrt(sum((Mach_dados2$Du2021)^2)/length(Mach_dados2$Du2021)))
Mach_dados2$du_dug<-as.numeric(Mach_dados2$du_dug)
Mach_dados2$influence_area_est<-2.5*(28.502*exp((-66.436+4.201*(Mach_dados2$du_dug))/(19.817+Mach_dados2$Du))/2) 
plot(Mach_dados2["influence_area_est"],pch=16)

xyA=st_coordinates(Mach_dados2)
matrixA<-dist(xyA, "euclidean") #Calculas as distancias em classe dist
matrixA=as.matrix(matrixA, labels=TRUE) #Passa o objecto de classe dist para matriz
colnames(matrixA) <- rownames(matrixA) <- Mach_dados2$continId
meltA <- melt(matrixA) #desfaz a matrix em colunas apenas
summary(meltA)

M101<-data.frame(Mach_dados2)
melt_0<-melt[which(meltA$value!=0),]  
submelt01<-meltA[melt_0$Var1 %in% M101$continId & melt_0$Var2 %in% M101$continId,]
submelt01<-submelt01[which(submelt01$value<33),]
submelt01<-submelt01[which(submelt01$value!=0),]
mt<-merge(submelt01, M101[,c("continId","influence_area_est" )], by.x="Var1", by.y="continId") #Criar uma coluna de diametros para a Var1, dependendo do nÃºmero da Ã¡rvore
mtt<-merge(mt, M101[,c("continId","influence_area_est" )], by.x="Var2", by.y="continId")  #Criar uma coluna de diametros para a Var2, dependendo do nÃºmero da Ã¡rvore
names(mtt)<-c(names(mtt)[1:3], "influence_area_est2",  "influence_area_est1") #mudar os nomes das colunas da novas da dataframe
head(mtt)
matrixA<-matrix(nrow=nrow(M101), ncol=nrow(M101))
for (k in c(1:nrow(mtt))){
  valor1<-mtt[k,1]
  valor2<-mtt[k,2]
  linha<- mtt[k,]
  #  matrixA[valor1,valor2]<- ifelse((linha$influence_area_est1 + linha$influence_area_est2 > linha$value),valor2,0)
  matrixA[valor1,valor2]<- ifelse((linha$influence_area_est1 + linha$influence_area_est2 > linha$value),1,0)
  }
matrixA[is.na(matrixA)] = 0
colnames(matrixA) <- rownames(matrixA) <- Mach_dados2$continId
View(matrixA)
WA<- mat2listw(matrixA)
par(cex=0.5, pch=16)
plot(WA,coord=st_coordinates(Mach_dados2), col="red")

#Global Moran's I test
moran.test(Mach_dados2$Du2021, listw=WA,zero.policy=TRUE)

#Correlogram construction and plotting 

 sp.correlogram(nlist, var=Mach_dados1$Cea_0.5m_1px, method="I", order=8)
 plot(sp.correlogram(nlist, var=Mach_dados1$Cea_0.5m_1px, method="I"))
 plot(sp.correlogram(  nb.k4 , var=Mach_dados1$Cea_0.5m_1px, method="I", order=4,zero.policy = TRUE))

#Local Moran's I Analysis
  localm<-localmoran(teste$Du2021, listw=Wk8,alternative = "greater")

  quadrant <- vector(mode="numeric",length=nrow(localm))
  m.qualification <- teste$Du2021 - mean(teste$Du2021)  # centers the variable of interest around its mean
  m.local <- localm[,1] - mean(localm[,1])    # centers the local Moran's around the mean
  signif <- 0.1 # significance threshold
  quadrant[m.qualification >0 & m.local>0] <- 4  # builds a data quadrant
  quadrant[m.qualification <0 & m.local<0] <- 1      
  quadrant[m.qualification <0 & m.local>0] <- 2
  quadrant[m.qualification >0 & m.local<0] <- 3
  quadrant[teste$localmoran2>signif] <- 0   
  # plot 
  brks <- c(0,1,2,3,4)
  colors <- c("grey","black","orange","red","darkgreen")
  plot(teste[1],col=colors[findInterval(quadrant,brks,all.inside=FALSE)], pch=c(1,18,16,16,16)[as.factor(quadrant)],main="")
  legend("bottomleft", legend = c("insignificant","low-low","low-high","high-low","high-high"),
        fill=colors,bty="n")
       
#######################################
# Non-spatial modelling

Mach<-Mach_dados1
st_geometry(Mach)=NULL
summary(lm(f , data=Dados_SpatialCorkOak1Tudo))
vif(lm(funcao, data=Dados_SpatialCorkOak1Tudo))
plot(lm(funcao, data=Dados_SpatialCorkOak1Tudo))
AIC(lm(funcao , data=Dados_SpatialCorkOak1Tudo))
 
 
 f<-as.formula("du~  Cea_1m_1px+  Cea_0.5m_1px+  slope_1px+  Elev_1px+  TRI_1px+  TPI_1px+  cos_aspect_1px+  TWI_1px")        #function for linear models on individual tree diameter for singular sites
 f<-as.formula("du_annual_growth~ Cea_1_mean+  Cea_0.5_mean+  slope_mean+  Elev_mean+  TRI_mean+ cos_aspect_mean+ TWI_mean")  #function for linear models on individual tree diameter for all data
 f<-as.formula("du_mean~  Cea_1m_mean+  Cea_0.5m_1px+  slope_1px+  Elev_1px+  TRI_1px+  TPI_1px+  cos_aspect_1px+  TWI_1px")  #function for linear models on mean tree diameter for singular sites
 f<-as.formula("mean_du_annual_growth~ Cea_1_mean+  Cea_0.5_mean+  slope_mean+  Elev_mean+  TRI_mean+ cos_aspect_mean+ TWI_mean") #function for linear models on mean tree diameter for all data
 
 
### Spatial modelling

duplicated(Mach_dados1$geometry)
 W <- nb2listw(WA$neighbours, style="W",zero.policy = TRUE)
 f <- as.formula("du~Cea_1m_1px+  Cea_0.5m_1px+  slope_1px+  Elev_1px+  TRI_1px+  TPI_1px+  cos_aspect_1px+  TWI_1px")

 
 mod.lag <- lagsarlm(f,Mach_dados2,listw=W,zero.policy = TRUE)
 summary(mod.lag)
 
 mod.err <- errorsarlm(f,data=Mach_dados2,listw=W,zero.policy = TRUE)
 summary(mod.err)
 
 LR.sarlm(m,mod.lag)
 LR.sarlm(m,mod.err)
 AIC(mod.lag,mod.err)
 
 mod.sac <- sacsarlm(f,data=Mach_dados2,listw=W,zero.policy = TRUE)
 LR.sarlm(mod.sac,mod.lag)
 LR.sarlm(mod.sac,mod.err)
 AIC(mod.lag,mod.err,mod.sac,n)
 summary(mod.sac)
 
 mod.sac2 <- sacsarlm(Du2021 ~ Cea_0.5m_1px+slope_1px+TRI_1px+TPI_1px+TWI_1px,data=Mach_dados1,listw=W,zero.policy = TRUE)
 summary(mod.sac2)
 AIC(mod.lag,mod.err,mod.sac, mod.sac2)
 hist(mod.sac2$residuals)
 qqnorm(mod.sac2$residuals)
 qqline(mod.sac2$residuals)
 plot(mod.sac2$residuals ~ fitted(mod.sac2), data=Mach_dados1)

 

