library(sf)
library(spdep)
library(whitebox)
library(car)
ibrary(spatialreg)
library(gstat)

###############################
###Section 1 - Data preparation and variable calculation
###############################
#Upload and prepare data file
Dados_SpatialCorkoak<-read_excel("C:/Users/caven/Google Drive (paulofirmino@e-isa.ulisboa.pt)/2023-Doutoramento/SpatialCorkoak/Dados_SpatialCorkOak.xlsx")
Dados_SpatialCorkoak<-st_as_sf(Dados_SpatialCorkoak, coords=c("coordsX","coordsY"))
parcela<-Dados_SpatialCorkOak[which(Dados_SpatialCorkOak$Site == "A"),] ## Select on of the 4 properties (A, B, C, D) - A and B are SantarÃ©m, C and D are Castelo Branco 
parcela<-st_as_sf(parcela, coords=c("coordsX","coordsY"),crs = 3763) #transform to sf object
parcela<-parcela[which(parcela$mais_velha == 0),]  ##Remove clearly older trees present in the plantation area
parcela_vivas<-parcela[which(parcela$Morta == 0),]  ##Remove dead trees
#"parcela_vivas" will be used when considering individual trees, #parcela# will be used when considering the group of trees approach 

##1. Variable calculation - Dependent and independent variables
#1.1 - Independent Variables (Cea_1m ; Cea_0.5m; Elev; slope; cos_aspect;TRI ;TPI; TWI)
# these variable are already calculated on the sf object. Code displayed in this section is only for informative purposes

#1.1.1 Geographical position indices calculation (TPI and TRI)
#f <- matrix(1, nrow=5, ncol=5)
#TPI <- focal(Altimetria, w=f, fun=function(x, ...) x[5] - mean(x[-5]), pad=TRUE, padValue=NA);plot(TPI)
#TRI <- focal(Altimetria, w=f, fun=function(x) sum(abs(x[-5]-x[5]))/8, pad=TRUE, padValue=NA);plot(TRI)

#1.1.2 Geographical position indices calculation (TWI)
# TWI calculation based on the methodology of https://vt-hydroinformatics.github.io/rgeoraster.html
  # Prepare DEM for Hydrology Analyses
#  wbt_breach_depressions_least_cost(dem = "/path/parcela_Altimetria.tif", output = "/path/parcela_DTM_breach.tif", dist = 5,  fill = TRUE)
#  wbt_fill_depressions_wang_and_liu(dem = "/path/parcela_DTM_breach.tif",output = "/path/parcela_DTM_breach_fill.tif")
  # Visualize and correct filled sinks and breached depression
#  filled_breached <- raster("/path/parcela_DTM_breach_fill.tif")
#  plot(filled_breached)
#    difference <- Altimetria - filled_breached
#  difference[difference == 0] <- NA
  #D infinity flow accumulation (alternative flow accumulation may be calculated from D infinity method D8 Flow Accumulation)
#  wbt_d_inf_flow_accumulation("/path/parcela_DTM_breach_fill.tif","/path/Infinit_FlowAccum.tif")
#  dinf <- raster("/path/Infinit_FlowAccum.tif");  plot(dinf)
  #Calculate Specific Contributing Area
#  wbt_d_inf_flow_accumulation(input = "/path/parcela_DTM_breach_fill.tif",output = "/path/FlowAccum2.tif", out_type = "Specific Contributing Area")
  #Calculate slope or use slope mapped tif from data
#  wbt_slope(dem = "/path/parcela_DTM_breach_fill.tif",output = "/path/parcela_slope_degrees.tif",units = "degrees")
  #Calculate topographic wetness index
#  wbt_wetness_index(sca = "/path/FlowAccum2.tif",slope = "/path/parcela_slope_degrees.tif", output = "/path/TWI.tif")              
#  twi <- raster("/path/TWI.tif");  plot(twi)

########
#1.2 Dependent variables - Calculate diameter related variables and attribute explanatory values to points

# Dependent variable is considered in the ways: 1) as the individual diameter annual growth; 2) as the basal area annual growth of a group of closely located trees
#Annual growth is considered so that all plots are normalized by age
########
#1.2.1 - Individual diameter annual growth
#Already calculated in dataframe as column "du_annual_growth"
             
#Attribute exploratory variable value according to the pixel where tree is positioned
#parcela$Cea_1m_1px<-extract(Cea_1m,parcela) #Variable Example, already on the dataframe
             
########
#1.2.2 - Basal area annual growth of a group of closely located trees
parcela$BA<-pi*(parcela$du^2)/4      #Individual tree basal area
parcela$annual_BA<-(pi*(parcela$du^2)/4)/parcela$t  #Annual growth in individual tree basal area (BA/t).

########                  
##Requires the definition of the tree groups. Trees may be grouped by a fixed number of individuals or by a fixed area
#1.2.2.1 - Definition of groups according to the 8 closest neighbours to a subject tree.
             
#Order the dataframe by tree coordinates. This is required to produce the best results in grouping, avoiding huge polygon when few individuals are still available.        
par <- parcela
xy = st_coordinates(par)
par = par[order(xy[,"X"], xy[,"Y"]),] #produces a modified sf object (ordered coordinates) to use for this part

#Prepares empty objects to be used on the cycle
polygon_list <- list() 
combined_pol <- st_polygon()
arvores<-data.frame()

#Cycle to create polygons representing the groups. Output generated by cycle:
  #1) "arvores" object, with the dataframe of tree groups, with basal area and independent variables    
  #2) "polygon_list", with the polygons representing the groups of trees
# Cycle works by selecting one tree and its 8 closests neighbours, and treats them as a unit
    #Dependent value is the sum of the 9 trees. Independent variables are the mean of the 9 trees pixel values
    #A polygon is generated containing all 9 points, to represent the unit in plots
    #The used point are removed so they are no considered in the next loop
    #cycle has 235 loop, but it actually end in the error message "not enough trees to continue". The number of loops until the error depend on the site.
    #Cycle is slow, each loop is faster as the dataframe is continuously smaller
             
for(i in c(1:235)) {
  #Create empty objects the neighbour selection. This must be cleared at the beginning at each loop
  arvsuj <- data.frame(matrix(NA,  ncol = dim(parcela)[2]))
  arv1 <- data.frame(matrix(NA,  ncol = dim(parcela)[2]))
  arv2 <- data.frame(matrix(NA,  ncol = dim(parcela)[2]))
  arv3 <- data.frame(matrix(NA,  ncol = dim(parcela)[2]))
  arv4 <- data.frame(matrix(NA,  ncol = dim(parcela)[2]))
  arv5 <- data.frame(matrix(NA,  ncol = dim(parcela)[2]))
  arv6 <- data.frame(matrix(NA,  ncol = dim(parcela)[2]))
  arv7 <- data.frame(matrix(NA,  ncol = dim(parcela)[2]))
  arv8 <- data.frame(matrix(NA,  ncol = dim(parcela)[2]))

  #Assing subject tree and 8 neighbours.
  par$continId<-c(1:dim(par)[1])  #ContinId must be re-generated each loop and will crash, as it is not continuous id after removing elements from dataframe
  arvsuj[1,]<-par[1,]
  arv1[1,]<-(par[which(par$continId == ((knearneigh(par, k=8)$nn[1,1]))),])
  arv2[1,]<-(par[which(par$continId == ((knearneigh(par, k=8)$nn[1,2]))),])
  arv3[1,]<-(par[which(par$continId == ((knearneigh(par, k=8)$nn[1,3]))),])
  arv4[1,]<-(par[which(par$continId == ((knearneigh(par, k=8)$nn[1,4]))),])
  arv5[1,]<-(par[which(par$continId == ((knearneigh(par, k=8)$nn[1,5]))),])
  arv6[1,]<-(par[which(par$continId == ((knearneigh(par, k=8)$nn[1,6]))),])
  arv7[1,]<-(par[which(par$continId == ((knearneigh(par, k=8)$nn[1,7]))),])
  arv8[1,]<-(par[which(par$continId == ((knearneigh(par, k=8)$nn[1,8]))),])
  colnames(arvsuj)<-colnames(arv1)<-colnames(arv2)<-colnames(arv3)<-colnames(arv4)<-colnames(arv5)<-colnames(arv6)<-colnames(arv7)<-colnames(arv8)<-colnames(par)             

  #Remove subject tree and 8 neighbours from dataframe
  par<-par[-which(par$continId == arvsuj[1,"continId"]),]
  par<-par[-which(par$continId == arv1[1,"continId"]),]
  par<-par[-which(par$continId == arv2[1,"continId"]),]
  par<-par[-which(par$continId == arv3[1,"continId"]),]
  par<-par[-which(par$continId == arv4[1,"continId"]),]
  par<-par[-which(par$continId == arv5[1,"continId"]),]
  par<-par[-which(par$continId == arv6[1,"continId"]),]
  par<-par[-which(par$continId == arv7[1,"continId"]),]
  par<-par[-which(par$continId == arv8[1,"continId"]),]

  #Create new dataframe, with the dependent and independent variables from the group unit
  b<-data.frame(matrix(NA,  ncol = 1))
  b$id<- arvsuj[1,"id"]
  b$continId<-arvsuj[1,"continId"]
  b$annual_BA<-arvsuj[1,"annual_BA"]+arv1[1,"annual_BA"]+arv2[1,"annual_BA"]+arv3[1,"annual_BA"]+arv4[1,"annual_BA"]+arv5[1,"annual_BA"]+arv6[1,"annual_BA"]+arv7[1,"annual_BA"]+ arv8[1,"annual_BA"]
  b$Cea_0.5m<-(arvsuj[1,"Cea_0.5m_1px"]+arv1[1,"Cea_0.5m_1px"]+arv2[1,"Cea_0.5m_1px"]+arv3[1,"Cea_0.5m_1px"]+
                arv4[1,"Cea_0.5m_1px"]+arv5[1,"Cea_0.5m_1px"]+arv6[1,"Cea_0.5m_1px"]+arv7[1,"Cea_0.5m_1px"]+
                arv8[1,"Cea_0.5m_1px"]/9)
  b$Cea_1m<-((arvsuj[1,"Cea_1m_1px"]+arv1[1,"Cea_1m_1px"]+arv2[1,"Cea_1m_1px"]+arv3[1,"Cea_1m_1px"]+
               arv4[1,"Cea_1m_1px"]+arv5[1,"Cea_1m_1px"]+arv6[1,"Cea_1m_1px"]+arv7[1,"Cea_1m_1px"]+
               arv8[1,"Cea_1m_1px"])/9)
  b$TRI<-((arvsuj[1,"TRI_1px"]+arv1[1,"TRI_1px"]+arv2[1,"TRI_1px"]+arv3[1,"TRI_1px"]+
             arv4[1,"TRI_1px"]+arv5[1,"TRI_1px"]+arv6[1,"TRI_1px"]+arv7[1,"TRI_1px"]+
             arv8[1,"TRI_1px"])/9)
  b$TPI<-((arvsuj[1,"TPI_1px"]+arv1[1,"TPI_tree_1px"]+arv2[1,"TPI_tree_1px"]+arv3[1,"TPI_tree_1px"]+
             arv4[1,"TPI_tree_1px"]+arv5[1,"TPI_tree_1px"]+arv6[1,"TPI_tree_1px"]+arv7[1,"TPI_tree_1px"]+
             arv8[1,"TPI_tree_1px"])/9)
  b$slope<-((arvsuj[1,"slope_1px"]+arv1[1,"slope_1px"]+arv2[1,"slope_1px"]+arv3[1,"slope_1px"]+
               arv4[1,"slope_1px"]+arv5[1,"slope_1px"]+arv6[1,"slope_1px"]+arv7[1,"slope_1px"]+
               arv8[1,"slope_1px"])/9)
  b$cos_aspect<-((arvsuj[1,"cos_aspect_1px"]+arv1[1,"cos_aspect_1px"]+arv2[1,"cos_aspect_1px"]+arv3[1,"cos_aspect_1px"]+
                 arv4[1,"cos_aspect_1px"]+arv5[1,"cos_aspect_1px"]+arv6[1,"cos_aspect_1px"]+arv7[1,"cos_aspect_1px"]+
                 arv8[1,"cos_aspect_1px"])/9)
  b$Elev<-((arvsuj[1,"Altimetria_1px"]+arv1[1,"Altimetria_1px"]+arv2[1,"Altimetria_1px"]+arv3[1,"Altimetria_1px"]+
              arv4[1,"Altimetria_1px"]+arv5[1,"Altimetria_1px"]+arv6[1,"Altimetria_1px"]+arv7[1,"Altimetria_1px"]+
              arv8[1,"Altimetria_1px"])/9)
  b$TWI<-((arvsuj[1,"TWI_tree_1px"]+arv1[1,"TWI_tree_1px"]+arv2[1,"TWI_tree_1px"]+arv3[1,"TWI_tree_1px"]+
             arv4[1,"TWI_tree_1px"]+arv5[1,"TWI_tree_1px"]+arv6[1,"TWI_tree_1px"]+arv7[1,"TWI_tree_1px"]+
             arv8[1,"TWI_tree_1px"])/9)
  b$geometry<-arvsuj[1,"geometry"]
  b<-b[,-1]  #removes the useless NA col
  arvores<-rbind(arvores,b) #stores each line on the object arvores

  #Creates a polygon that overlays all 9 points
  arv_neigh<-rbind(arvsuj[1,],arv1[1,],arv2[1,],arv3[1,],arv4[1,],arv5[1,],arv6[1,],arv7[1,],arv8[1,])
  arv_neigh<-st_as_sf(arv_neigh,crs=3763)
  points_matrix <- as.matrix(st_coordinates(arv_neigh))
  hull_indices <- chull(points_matrix) #creates a convex hull
  convex_hull_points <- points_matrix[hull_indices, ]
  convex_hull_points <- rbind(convex_hull_points, convex_hull_points[1, ]) #Requires to add again the first point or the polygon will not close
  polygon <- st_polygon(list(convex_hull_points)) #completes the polygon
  polygon_list[[i]]<- polygon #stores to polygon on the polygon_list object
  print(i)  #prints at which loop it is
}
#Prepares to plot all the polygons
combined_polygon <- st_sfc(polygon_list)
combined_polygon <- combined_polygon[!st_is_empty(combined_polygon),drop=FALSE] #removes any generated empty geometry
combined_polygon$area<-st_area(combined_polygon)
combined_polygon<-combined_polygon[which(combined_polygon$area < 200)] #area may be used to remove huge polygon
#Plot points and polygons
graph<-(ggplot() +  geom_sf(data = combined_polygon, col="darkgreen",fill="orange",size=1.2)+ geom_point(data = parcela, aes(x = st_coordinates(parcela)[,1], y = st_coordinates(parcela)[,2])))
graph

######
#Evaluation:
#Method creates mostly similar polygon sizes, as much as the plantation spacial allows.
#The plots seem to be well represented by the polygons, which are now independent of each other
#Each polygon has the same number of trees, which makes a fair comparison using the sum of basal area  
                      
#1.2.2.2 # Definition of groups according fixed sized area. *Only informative purpose*
#Cell size was tried for combinations 10x8, 16x8, 20x10, 20x15, 20x20, depending on tree spacing. Idea is to have similar number of trees per unit: 4-6 ; 7-9; 9-12.    

#Sets a grid with custom size, to "cut" the are in units. Cycle output is multiply polygons object "a_parc", with values of the dependent and independent variables    
grid1<-st_make_grid(parcela, cellsize=c(15,20))
a_parc<-st_sf(st_sfc()) #create new empty object to fill by the cycle
            
for(i in c(1:length(grid1))) {
  pol<-st_crop(parcela, grid1[i])  #for each gridded unit, cuts a part of the area and gives variable values to each polygon
  pol2<-length(pol$id) #number of trees per unit
  pol3<-sum(pol$annual_BA)
  pol4<-mean(pol$Cea_0.5m_1px)
  pol5<-mean(pol$Cea_1m_1px)
  pol6<-mean(pol$slope_1px)
  pol7<-mean(pol$Elev_1px)
  pol8<-mean(pol$TRI_1px)
  pol9<-mean(pol$TPI_1px)
  pol10<-mean(pol$cos_aspect_1px)
  pol11<-mean(pol$TWI_1px)
  
  a_parc[i,]<-merge(grid1[i],pol3) #store values of each unit on sf empty object
  a_parc[i,2]<-pol2
  a_parc[i,3]<-pol3
  a_parc[i,4]<-pol4
  a_parc[i,5]<-pol5
  a_parc[i,6]<-pol6
  a_parc[i,7]<-pol7
  a_parc[i,8]<-pol8
  a_parc[i,9]<-pol9
  a_parc[i,10]<-pol10
  a_parc[i,11]<-pol11
}
a_parc<-na.omit(a_parc) 
st_geometry(a_parc)<-(a_parc[,1])
nomes<-c("st_sfc..","Tree_Count","BA","Cea_0.5m","Cea_1m","slope","Elev","TRI","TPI","cos_asp","TWI");colnames(a_parc)<-nomes
plot(a_parc["Tree_Count"],main="Tree_Count")
a_parc$BA<-as.numeric(a_parc$BA);plot(a_parc["BA"],main="Tree_BA")

######
#Evaluation:
#Method creates identical polygon sizes, independent of the plantation spacing           
#The plots are fully represented by the polygons, which are now independent of each other
#The number of trees inside polygons varies, and does not allow a correct usage of the sum of basal area. The alternative would have to be the mean of basal area.

##################################################################################################################################
#### Group definition method selection according to results plot representation, consistency of size and number of tree per polygon           
#Definition of groups according to the 8 closest neighbours to a subject tree is selected to modelling phase.



             
###############################
##2. Spatial autocorrelation analysis
###############################
#Section 2 - Spatial autocorrelation analysis
#Spatial autocorrelation analysis is applied to each plot separately, with the following steps: 
#1) Spatial matrix definition;
#2) Spatial weights definition; 
#3) Global Moran's I analysis
#4) Correlogram (Moran's I statistics) analysis
#5) Local Moran's I analysis
             
########
##2.1 Spatial matrix definition
########             
#Although plantations are regular, trees are not at exact distances to make preferable the using of polygons for analysis.
#Its opted using points for the analysis. Output of 2.1 is nb object.
#Three methods are tested to choice the proper spatial matrix 
#1) Distance based neighbours; k neighbours; Tree area of influence sobreposition
#2.1.1 Distance base neighbours nb objects creation - Selected 8, 10 and 15m. The idea is capture links according to plantation spacing
dnearneigh(parcela_vivas, d1=0, d2=8)
dnearneigh(parcela_vivas, d1=0, d2=10)
dnearneigh(parcela_vivas, d1=0, d2=15)
#2.1.2 k neighbours - Selected 4 and 8 neighbours.
knn2nb(knearneigh(parcela_vivas, k=4))
knn2nb(knearneigh(parcela_vivas, k=8))
#2.1.3  Tree area of influence sobreposition
#Requires 3 steps: 
#1)Calculating individual tree area of influence;
#2)Creating of neighbour/distance table; 
#3)Identifying the trees with sobreposed areas of influence and providing a value for them as neighbours

#2.1.3.1  Calculating individual tree area of influence, according Paulo et al. 2016
parcela_vivas$du_dug<-""
parcela_vivas$du_dug<-parcela_vivas$du/(sqrt(sum((parcela_vivas$du)^2)/length(parcela_vivas$du)))
parcela_vivas$du_dug<-as.numeric(parcela_vivas$du_dug)
parcela_vivas$influence_area_est<-2.5*(28.502*exp((-66.436+4.201*(parcela_vivas$du_dug))/(19.817+parcela_vivas$du))/2) 
plot(parcela_vivas["influence_area_est"],pch=16)

#2.1.3.2 Creating of neighbour/distance table; 
parcela_vivas$continId<-c(1:dim(parcela_vivas)[1])#remake the continId for parcela_vivas, after removing dead elements
xy<-st_coordinates(parcela_vivas)
matrix<-as.matrix(dist(xy, "euclidean"), labels=TRUE) #Distance matrix
colnames(matrix) <- rownames(matrix) <- parcela_vivas$continId #Name rows and columns
melt <- melt(matrix) #unmaked the matrix to columns
M101<-data.frame(parcela_vivas)
melt_0<-melt[which(melt$value!=0),]  #removes the distances=zero
submelt01<-melt[melt_0$Var1 %in% M101$continId & melt_0$Var2 %in% M101$continId,] #creates a table with Var1, Var2 and the distance value between then
submelt01<-submelt01[which(submelt01$value<33),] #Removes any lines with distace > 33m, which is the highest distance between two neighbouring trees. This condition fastens the process.
submelt01<-submelt01[which(submelt01$value!=0),] #Removes distances =0
mt<-merge(submelt01, M101[,c("continId","influence_area_est" )], by.x="Var1", by.y="continId") #Creates a diameter column for Var1, depending on tree number
mtt<-merge(mt, M101[,c("continId","influence_area_est" )], by.x="Var2", by.y="continId") #Creates a diameter column for Var2, depending on tree number
names(mtt)<-c(names(mtt)[1:3], "influence_area_est2",  "influence_area_est1") #change the names of the two new columns
head(mtt)

#2.1.3.3 Identifying the trees with sobreposed areas of influence and providing a value for them as neighbours
matrix<-matrix(nrow=dim(parcela_vivas)[1], ncol=dim(parcela_vivas)[1]) #starts a blank matrix for the cycle
for (k in c(1:nrow(mtt))){ 
  valor1<-mtt[k,1]
  valor2<-mtt[k,2]
  linha<- mtt[k,]
  matrix[valor1,valor2]<- ifelse((linha$influence_area_est1 + linha$influence_area_est2 > linha$value),1,0)
}
#asks if the sum of radius of area of influence of two trees is higher than their distance. 
#If true, they are neighbours. The value attributed if neighbours can work as a weight. In this case is 1, similar to binary case.

matrix[is.na(matrix)] = 0 #turns NA to zeros
colnames(matrix) <- rownames(matrix) <- parcela_vivas$continId #give names to new matrix
#View(matrix) #check if result is correct
W<- mat2listw(matrix) #creates a listw object from this matrix, ready to be applied, with style=matrix itself.
WW<-mat2listw(matrix,style = "W")

###Repeat the cycle about attribute the distance between instead of 1. 
matrix<-matrix(nrow=dim(parcela_vivas)[1], ncol=dim(parcela_vivas)[1]) #starts a blank matrix for the cycle
for (k in c(1:nrow(mtt))){ 
  valor1<-mtt[k,1]
  valor2<-mtt[k,2]
  linha<- mtt[k,]
  matrix[valor1,valor2]<- ifelse((linha$influence_area_est1 + linha$influence_area_est2 > linha$value),linha$value,0)
}
matrix[is.na(matrix)] = 0 #turns NA to zeros
colnames(matrix) <- rownames(matrix) <- parcela_vivas$continId #give names to new matrix
#View(matrix) #check if result is correct
Wdist<- mat2listw(matrix) #creates a listw object from this matrix, this time with dist as weights

####2.1.4  Plot and compare results
par(mfrow=c(2,3));par(cex=0.4, pch=16)
plot(dnearneigh(parcela_vivas, d1=0, d2=8), coord=(parcela_vivas$geometry), col="red");title(main=paste("Distance based neighbours - 8m"),cex.main=2)
plot(dnearneigh(parcela_vivas, d1=0, d2=10), coord=(parcela_vivas$geometry), col="red");title(main=paste("Distance based neighbours -10m"),cex.main=2)
plot(dnearneigh(parcela_vivas, d1=0, d2=15), coord=(parcela_vivas$geometry), col="red");title(main=paste("Distance based neighbours - 15m"),cex.main=2)
plot(knn2nb(knearneigh(parcela_vivas, k=4)), coord=(parcela_vivas$geometry), col="red");title(main=paste("k neighbours - 4"),cex.main=2)
plot(knn2nb(knearneigh(parcela_vivas, k=8)), coord=(parcela_vivas$geometry), col="red");title(main=paste("k neighbours - 8"),cex.main=2)
plot(W,coord=(parcela_vivas$geometry),col="red"); title(main=paste("Area of Influence approach"),cex.main=2)

######
#Evaluation: 
#8m distance and k=4 neighbours seem to underestimate the amount of links per tree
#15m distance seems to overestimate the amount of links per tree    
#10 distance and k=8 seem to have a most realistic number and distribution of neighbours
#Area of Influence approach seems to work better on site A and B, where tree size is more regular
#Area of Influence approach may overestimate the neighbours in larger trees
#Area of Influence approach underestimate spatial autocorrelation in very small trees (very few or no neighbours) in C and D
########

             
##2.1.2 Spatial weights matrix definition
########    
##Three methods are tested to choose weights: 1) row-normalized (W); 2) Binary (B); Inverse of distance (idw)
#The three methods generate distinct spatial weight matrices, an object class listw
#Example of a previously defined nb object
nb2listw(dnearneigh(parcela_vivas, d1=0, d2=8),zero.policy = TRUE, style="W") #row-normalized
nb2listw(dnearneigh(parcela_vivas, d1=0, d2=8),zero.policy = TRUE,style="B") #binary
nb2listwdist(nb2listw(dnearneigh(parcela_vivas, d1=0, d2=8),zero.policy = TRUE)) #idw        

#To select the most suitable weights, they are compared on the following spatial analysis functions

########
##2.2 Global Moran'I test
########  
# A table can be created fro each plot to compare the multiple methods outputs: Morans'I statistic and respective p-value.
#Example of the output table, plot A:
#                         Weights    Row-normalized          Inverse Distance                    Binary        
#                          Method Moran I statistic p-value Moran I statistic p-value Moran I statistic p-value
#  Distance based neighbours - 8m              0.16       0             0.187       0             0.145       0
# Distance based neighbours - 10m             0.129       0             0.154       0              0.12       0
# Distance based neighbours - 15m             0.129       0             0.136       0             0.112       0
#                k neighbours - 4             0.158       0             0.193       0             0.158       0
#                k neighbours - 8             0.127       0             0.156       0             0.127       0
#      Area of Influence approach              0.07   4e-05             0.102       0             0.103       0


tabela<-data.frame()
tabela[1,1]<- "Method"
tabela[2,1]<- "Distance based neighbours - 8m"
tabela[3,1]<- "Distance based neighbours - 10m"
tabela[4,1]<- "Distance based neighbours - 15m"
tabela[5,1]<- " k neighbours - 4"
tabela[6,1]<- " k neighbours - 8"
tabela[7,1]<- "Area of Influence approach"
tabela[1,2]<-"Moran I statistic";tabela[1,3]<-"p-value";tabela[1,4]<-"Moran I statistic";tabela[1,5]<-"p-value";tabela[1,6]<-"Moran I statistic";tabela[1,7]<-"p-value";
#distance base tests - row-normalized weights; zero.policy=TRUE must be present since there is always points with no (living) neighbours
tabela[2,2]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(dnearneigh(parcela_vivas, d1=0, d2=8),zero.policy = TRUE),zero.policy=TRUE)$estimate[1],3)
tabela[2,3]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(dnearneigh(parcela_vivas, d1=0, d2=8),zero.policy = TRUE),zero.policy=TRUE)$p.value,5)
tabela[3,2]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(dnearneigh(parcela_vivas, d1=0, d2=10),zero.policy = TRUE),zero.policy=TRUE)$estimate[1],3)
tabela[3,3]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(dnearneigh(parcela_vivas, d1=0, d2=10),zero.policy = TRUE),zero.policy=TRUE)$p.value,5)
tabela[4,2]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(dnearneigh(parcela_vivas, d1=0, d2=15),zero.policy = TRUE),zero.policy=TRUE)$estimate[1],3)
tabela[4,3]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(dnearneigh(parcela_vivas, d1=0, d2=15),zero.policy = TRUE),zero.policy=TRUE)$p.value,5)
#distance base tests - inverse of distance weights; can be used nb2listwdist function
tabela[2,4]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listwdist(nb2listw(dnearneigh(parcela_vivas, d1=0, d2=8),zero.policy = TRUE)$n,parcela_vivas,type="idw",zero.policy = TRUE),zero.policy=TRUE)$estimate[1],3)
tabela[2,5]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listwdist(nb2listw(dnearneigh(parcela_vivas, d1=0, d2=8),zero.policy = TRUE)$n,parcela_vivas,type="idw",zero.policy = TRUE),zero.policy=TRUE)$p.value,5)
tabela[3,4]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listwdist(nb2listw(dnearneigh(parcela_vivas, d1=0, d2=10),zero.policy = TRUE)$n,parcela_vivas,type="idw",zero.policy = TRUE),zero.policy=TRUE)$estimate[1],3)
tabela[3,5]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listwdist(nb2listw(dnearneigh(parcela_vivas, d1=0, d2=10),zero.policy = TRUE)$n,parcela_vivas,type="idw",zero.policy = TRUE),zero.policy=TRUE)$p.value,5)
tabela[4,4]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listwdist(nb2listw(dnearneigh(parcela_vivas, d1=0, d2=15),zero.policy = TRUE)$n,parcela_vivas,type="idw",zero.policy = TRUE),zero.policy=TRUE)$estimate[1],3)
tabela[4,5]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listwdist(nb2listw(dnearneigh(parcela_vivas, d1=0, d2=15),zero.policy = TRUE)$n,parcela_vivas,type="idw",zero.policy = TRUE),zero.policy=TRUE)$p.value,5)
#distance base tests - binary weights
tabela[2,6]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(dnearneigh(parcela_vivas, d1=0, d2=8),zero.policy = TRUE,style="B"),zero.policy=TRUE)$estimate[1],3)
tabela[2,7]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(dnearneigh(parcela_vivas, d1=0, d2=8),zero.policy = TRUE,style="B"),zero.policy=TRUE)$p.value,5)
tabela[3,6]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(dnearneigh(parcela_vivas, d1=0, d2=10),zero.policy = TRUE,style="B"),zero.policy=TRUE)$estimate[1],3)
tabela[3,7]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(dnearneigh(parcela_vivas, d1=0, d2=10),zero.policy = TRUE,style="B"),zero.policy=TRUE)$p.value,5)
tabela[4,6]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(dnearneigh(parcela_vivas, d1=0, d2=15),zero.policy = TRUE,style="B"),zero.policy=TRUE)$estimate[1],3)
tabela[4,7]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(dnearneigh(parcela_vivas, d1=0, d2=15),zero.policy = TRUE,style="B"),zero.policy=TRUE)$p.value,5)
#k neighbours - row-normalized weights
tabela[5,2]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(knn2nb(knearneigh(parcela_vivas, k=4)),style="W"),zero.policy=TRUE)$estimate[1],3)
tabela[5,3]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(knn2nb(knearneigh(parcela_vivas, k=4)),style="W"),zero.policy=TRUE)$p.value,5)
tabela[6,2]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(knn2nb(knearneigh(parcela_vivas, k=8)),style="W"),zero.policy=TRUE)$estimate[1],3)
tabela[6,3]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(knn2nb(knearneigh(parcela_vivas, k=8)),style="W"),zero.policy=TRUE)$p.value,5)
#k neighbours - inverse of distance weights 
tabela[5,4]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listwdist(nb2listw(knn2nb(knearneigh(parcela_vivas, k=4)))$n,parcela_vivas,type="idw"),zero.policy=TRUE)$estimate[1],3)
tabela[5,5]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listwdist(nb2listw(knn2nb(knearneigh(parcela_vivas, k=4)))$n,parcela_vivas,type="idw"),zero.policy=TRUE)$p.value,5)
tabela[6,4]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listwdist(nb2listw(knn2nb(knearneigh(parcela_vivas, k=8)))$n,parcela_vivas,type="idw"),zero.policy=TRUE)$estimate[1],3)
tabela[6,5]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listwdist(nb2listw(knn2nb(knearneigh(parcela_vivas, k=8)))$n,parcela_vivas,type="idw"),zero.policy=TRUE)$p.value,5)
#k neighbours - binary weights
tabela[5,6]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(knn2nb(knearneigh(parcela_vivas, k=4)),style="B"),zero.policy=TRUE)$estimate[1],3)
tabela[5,7]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(knn2nb(knearneigh(parcela_vivas, k=4)),style="B"),zero.policy=TRUE)$p.value,5)
tabela[6,6]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(knn2nb(knearneigh(parcela_vivas, k=8)),style="B"),zero.policy=TRUE)$estimate[1],3)
tabela[6,7]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(knn2nb(knearneigh(parcela_vivas, k=8)),style="B"),zero.policy=TRUE)$p.value,5)
#Area of influence neighbours - three weights (WW, Wdist, W)
tabela[7,2]<-round(moran.test(parcela_vivas$du_annual_growth,WCW, zero.policy=TRUE)$estimate[1],3)
tabela[7,3]<-round(moran.test(parcela_vivas$du_annual_growth,WCW, zero.policy=TRUE)$p.value,5)
tabela[7,4]<-round(moran.test(parcela_vivas$du_annual_growth,WCdist, zero.policy=TRUE)$estimate[1],3)
tabela[7,5]<-round(moran.test(parcela_vivas$du_annual_growth,WCdist, zero.policy=TRUE)$p.value,5)
tabela[7,6]<-round(moran.test(parcela_vivas$du_annual_growth,WC, zero.policy=TRUE)$estimate[1],3)
tabela[7,7]<-round(moran.test(parcela_vivas$du_annual_growth,WC, zero.policy=TRUE)$p.value,5)
nomes<-c("Weights","Row-normalized","","Inverse Distance","", "Binary","");colnames(tabela)<-nomes
#tabelaA<-tabela #save the table

#######
#Evaluation:
#Generally similar results on Moran I statistics on distance based and k-neighbours spatial matrices. 
#Area of influence method with distinct results, and depends on the plot
#Row-normalized and Binary weights produce same results on k-neighbours methods, as expected
#idw weights show consistent slightly higher Moran's I statistics, except for site C (?)
#8m distance base and k4 neighbours show slightly higher Moran's I statistics for any weights

########
##2.3 Correlogram
########
par(mfrow=c(2,3))
plot(sp.correlogram(knn2nb(knearneigh(parcela_vivas, k=4)), parcela_vivas$du_annual_growth, method="I" ,order=9,zero.policy=TRUE),ylim=c(0,0.35), main="k4 neighbours")
plot(sp.correlogram(knn2nb(knearneigh(parcela_vivas, k=8)), parcela_vivas$du_annual_growth, method="I" ,order=9,zero.policy=TRUE),ylim=c(0,0.35), main="k8 neighbours")
plot(sp.correlogram(dnearneigh(parcela_vivas, d1=0, d2=8), parcela_vivas$du_annual_growth, method="I" ,order=9,zero.policy=TRUE),ylim=c(0,0.35), main="dist 8m")
plot(sp.correlogram(dnearneigh(parcela_vivas, d1=0, d2=10), parcela_vivas$du_annual_growth, method="I" ,order=9,zero.policy=TRUE),ylim=c(0,0.35), main="dist 10m")
plot(sp.correlogram(dnearneigh(parcela_vivas, d1=0, d2=15), parcela_vivas$du_annual_growth, method="I" ,order=9,zero.policy=TRUE),ylim=c(0,0.35) ,main="dist 15m")
plot(sp.correlogram(W$neighbours, parcela_vivas$du_annual_growth, method="I" ,order=9,zero.policy=TRUE),ylim=c(0,0.35) ,main="Area of Influence")

#######
#Evaluation:
#Lower k neighbours or distance show highest error bars, values tend to stay similar in lags
#K-neighbours and distance approach tend to show similar results
#Area of influence approach produce distinct results. Its more difficult to explain the lag system with this nb object
#Checking Area of influence approach correlogram $cardnos argument show very variable number of neighbours

########
##2.4 Local Moran's I plot
########
#A plot can be created to check 1) the precision of the higher and lower clusters; 2) if they clusters are in accordance to field observations
#A plot is created for the six neighbours approaches used before

#localm<-localmoran(parcela_vivas$du_annual_growth, listw=nb2listw(dnearneigh(parcela_vivas, d1=0, d2=8),zero.policy = TRUE,style="W"),alternative = "greater",zero.policy = TRUE)
#localm<-localmoran(parcela_vivas$du_annual_growth, listw=nb2listw(dnearneigh(parcela_vivas, d1=0, d2=10),zero.policy = TRUE,style="W"),alternative = "greater",zero.policy = TRUE)
#localm<-localmoran(parcela_vivas$du_annual_growth, listw=nb2listw(dnearneigh(parcela_vivas, d1=0, d2=15),zero.policy = TRUE,style="W"),alternative = "greater",zero.policy = TRUE)
#localm<-localmoran(parcela_vivas$du_annual_growth, listw=nb2listw(knn2nb(knearneigh(parcela_vivas, k=4)),zero.policy = TRUE,style="W"),alternative = "greater",zero.policy = TRUE)
#localm<-localmoran(parcela_vivas$du_annual_growth, listw=nb2listw(knn2nb(knearneigh(parcela_vivas, k=8)),zero.policy = TRUE,style="W"),alternative = "greater",zero.policy = TRUE)
#localm<-localmoran(parcela_vivas$du_annual_growth, listw=WW,alternative = "greater")

#Prepare an object for the plot
local_plot<-parcela_vivas  
quadrant <- vector(mode = "numeric", length = nrow(localm)) #prepares a vector to receive a categorical value according to each quadrant
m.qualification <- local_plot$du_annual_growth - mean(local_plot$du_annual_growth) # centers the variable of interest around its mean
m.local <- localm[, "Ii"] - mean(na.omit(localm[, "Ii"])) # centers the local Moran's around the mean
signif <- 0.1# significance threshold - important for minimizing the outliers low-low and high-high  

# builds a data quadrant
quadrant[m.qualification > 0 & m.local > 0] <- 4 #high-high values
quadrant[m.qualification < 0 & m.local < 0] <- 1 #low-low values
quadrant[m.qualification < 0 & m.local > 0] <- 2 #low-high values
quadrant[m.qualification > 0 & m.local < 0] <- 3 #high-low values
quadrant[localm[, "Pr(z > 0)"] > signif] <- 0 #other values

# plot in r
brks <- c(0, 1, 2, 3, 4)
colors <- c("grey", "black", "orange", "red", "darkgreen")
plot(local_plot[1],  col = colors[findInterval(quadrant, brks, all.inside = FALSE)],  pch = c(1, 18, 16, 16, 16)[as.factor(quadrant)])
legend("bottomleft", legend = c("insignificant","low-low","low-high","high-low","high-high"),fill=colors,bty="n")

#######
#Evaluation:
#k-4 and 8m dist produces a plot with low focus in comparing to others. This is most relevant for plot A, where there is less spatial autocorrelation
#k-8, 10m, and 15m seem to produce intended clusters, with a tradeoff in precision/clusters size
#Area of influence approach fails at plotting realistic clusters

##################################################################################################################################
#### Spatial weights matrix selection according to results from neighbours network, correlogram, global moran's I and local moran's I.
#nb neighbours network --  k4, dist 8m, dist 15m and AIA were considered less adequate
#correlograms -- k4, dist 8m and AIA were considered less adequate        
#Global Moran's I test -- AIA was considered less adequate   
#Local Moran's I test -- k4, dist 8m and AIA were considered less adequate     

#Due to potentially being more accurate/balanced in describing the data, two spatial matrices will continue to the modelling phase: k-8 and dist 10m.


             
             
###############################
##3. Modelling
###############################
#Section 3 - Non-spatial and spatial modelling
#Non-spatial and spatial models will be fitted to each plot separately, and to all data, with the following steps: 
#1) Non-spatial linear modelling - Individual tree and tree group methods
#2) Spatial linear modelling; 

########
##3.1 Non-spatial modelling 
########
##3.3.1 Individual tree linear modelling
########                
X<-parcela_vivas
st_geometry(X)=NULL
f<-(du_annual_growth~Cea_0.5m_1px+Cea_1m_1px+Elev_1px+slope_1px+cos_aspect_1px+TRI_1px+TPI_1px+TWI_1px)

#Automatic stepwise selection of variables
mod<-(step(lm(f, data=X)))
summary(mod)
vif(mod) #check multicollinearity
plot(mod) #plot residuals

#Manual selection of variables - add biological interpretation to variable selection
summary(lm(du_annual_growth~Cea_0.5m_1px+Cea_1m_1px+ TPI_tree_1px+TWI_tree_1px, data=X))

########
##3.3.2  Group linear modelling
######## 
###Two methods were tested for creat tree group units: 1) groups of k-8 neighbours (groups of 9 trees); 2) groups by intersection of tree in fixed area grids.
X<-arvores
f<-(annuak_BA~Cea_0.5m+Cea_1m+Elev+slope+cos_aspect+TRI+TPI+TWI)
mod2<-(step(lm(f, data=X)))
summary(mod2)
vif(mod2) #check multicollinearity
plot(mod2) #plot residuals



########
##3.3.3  Spatial modelling
######## 
##3.3.3.1  #Spatial models as form of model parameter sensitivity analysis to a proper spatial weights matrix
########
#Spatial modelling consisting in fitting the spatial lag model (check rho parameter), spatial error (check lambda parameter) and if needed SAC model (rho and lambda)
#A table (tabela) of the outputs of the spatial models to evaluate the parameter models, on the format:
#Spatial Lag Model A																										
#	                                 Row-normalized				                     	 Inverse distance				                   Binary				
#Method	                           Rho	 p-value	Loglikelihood	AIC	    R2	   Rho	p-value	Loglikelihood	AIC     R2	   Rho	p-value	Loglikelihood 	AIC	  R2
#Distance based neighbours - 8m	   0.12	  0	        25.792	   -29.6	0.0588	-0.009	0.771	  18.61	     -15.2	0.0375	0.008	  0.202	   19.381	   -16.8	0.0395
#Distance based neighbours - 10m	 0.202	0	        27.194	   -32.4	0.0643	 0.029	0.278	  19.156	   -16.3	0.0389	0.012	  0.005	   22.43	   -22.9	0.0472
#Distance based neighbours - 15m	 0.391	0	        36.169	   -50.3	0.0909	 0.043	0.037	  20.749	   -19.5	0.0429	0.008	  0.001	   24.357	   -26.7	0.0517
#k neighbours - 4	                 0.238	0	        32.115	   -42.2	0.0801	 0.05 	0.296	  19.114	   -16.2	0.039	  0.06	   0	     32.115	   -42.2	0.0801
#k neighbours - 8	                 0.316	0	        32.389	   -42.8	0.0803	 0.068	0.071	  20.193	   -18.4	0.042	  0.039	   0	     32.389	   -42.8	0.0803
#Area of Influence approach	       0.2	  0.001	    23.848	   -25.7	0.0541	 0	    0	      291.116	   -560.2	0.5072	0	       0	     221.745	-421.5	0.4192

#A second table (tabela2) of the variable outputs from the models, on the format:
#	Spatial Lags Model A											
#	             Distance based - 8m		Distance based  - 10m		Distance based  - 15m		k neighbours - 4			k neighbours - 8		Area of Influence approach	
#Row-normalized	Estimate	p-value	     Estimate	p-value		     Estimate	 p-value	    Estimate	p-value		  Estimate	p-value	    Estimate	p-value
#(Intercept)	   4.5292	  0.0058	     4.0769	  0.0133		      3.0201	 0.0649	        3.8660	0.0181		    3.3218	0.0432	    3.8647	0.0208
#Cea_0.5m_1px	  -0.0620	  0.2512	    -0.0621	  0.2483		     -0.0560	 0.2913	       -0.0618	0.2462		   -0.0596	0.2636	   -0.0622	0.2503
#Cea_1m_1px	     0.0233	  0.6144	     0.0186	  0.6864		      0.0222	 0.6254	        0.0175	0.7014		    0.0252	0.5813	    0.0177	0.7014
#Altimetria_1px	-0.0239	  0.0188	    -0.0213	  0.0359		     -0.0158	 0.1163	       -0.0202	0.0451		   -0.0173	0.0870	   -0.0202	0.0500
#slope_1px	    -0.0103	  0.6609	    -0.0105	  0.6516		     -0.0091	 0.6937	       -0.0066	0.7766		   -0.0085	0.7134	   -0.0075	0.7475
#cos_aspect_1px	-0.0131	  0.2573	    -0.0137	  0.2358		     -0.0132	 0.2484	       -0.0142	0.2166		   -0.0139	0.2264	   -0.0138	0.2344
#TRI_1px	       0.0091	  0.9491	     0.0091	  0.9493		      0.0124	 0.9294	       -0.0056	0.9681		    0.0085	0.9519	   -0.0113	0.9371
#TPI_tree_1px	  -0.1665	  0.0398	    -0.1559	  0.0539		     -0.1247	 0.1186	       -0.1564	0.0508		   -0.1465	0.0684	   -0.1705	0.0370
#TWI_tree_1px	   0.0163	  0.1330	     0.0170	  0.1144		      0.0156	 0.1435	        0.0177	0.0973		    0.0156	0.1444	    0.0184	0.0903

#The code is extense since is not in a cycle yet. Its slow. Its displayed for spatial lags as an example. All outputs are provided in a excel sheet.
#Set the table empty object and the name column
f <- as.formula("du_annual_growth~Cea_0.5m_1px+Cea_1m_1px+Altimetria_1px+slope_1px+cos_aspect_1px+TRI_1px+TPI_tree_1px+TWI_tree_1px") 
tabela<-data.frame()
tabela[1,1]<- "Method"
tabela[2,1]<- "Distance based neighbours - 8m"
tabela[3,1]<- "Distance based neighbours - 10m"
tabela[4,1]<- "Distance based neighbours - 15m"
tabela[5,1]<- " k neighbours - 4"
tabela[6,1]<- " k neighbours - 8"
tabela[7,1]<- "Area of Influence approach"
tabela[1,2]<-"Rho";tabela[1,3]<-"p-value";tabela[1,4]<-"Loglikelihood";tabela[1,5]<-"AIC";tabela[1,6]<-"Rsquared";
tabela[1,7]<- "Rho";tabela[1,8]<-"p-value";tabela[1,9]<-"Loglikelihood";tabela[1,10]<-"AIC";tabela[1,11]<-"Rsquared";
tabela[1,12]<- "Rho";tabela[1,13]<-"p-value";tabela[1,14]<-"Loglikelihood";tabela[1,15]<-"AIC";tabela[1,16]<-"Rsquared";
tabela2<-data.frame()
tabela2[1,1]<-"(Intercept)";tabela2[2,1]<-"Cea_0.5m_1px";tabela2[3,1]<-"Cea_1m_1px";tabela2[4,1]<-"Altimetria_1px";
tabela2[5,1]<-"slope_1px";tabela2[6,1]<-"cos_aspect_1px";tabela2[7,1]<-"TRI_1px";tabela2[8,1]<-"TPI_tree_1px";tabela2[9,1]<-"TWI_tree_1px"

mod.lag<-lagsarlm(f,data=parcela_vivas,listw=nb2listw(dnearneigh(parcela_vivas, d1=0, d2=8),zero.policy = TRUE),zero.policy = TRUE)
tabela[2,2]<-round(mod.lag$rho,3)
tabela[2,3]<-round(LR.Sarlm(mod.lag, lm(f, data=parcela_vivas))$p.value[1],3)
tabela[2,4]<-round(mod.lag$LL,3)
tabela[2,5]<-round(AIC(mod.lag),1)
tabela[2,6]<-1-(sum((parcela_vivas$du_annual_growth-(mod.lag$fitted.values))^2)/sum((parcela_vivas$du_annual_growth-mean(parcela_vivas$du_annual_growth))^2))
tabela2[,2]<-round(summary(mod.lag)$Coef[,"Estimate"],4)
tabela2[,3]<-round(summary(mod.lag)$Coef[,"Pr(>|z|)"],4)
mod.lag<-lagsarlm(f,data=parcela_vivas,listw=nb2listw(dnearneigh(parcela_vivas, d1=0, d2=10),zero.policy = TRUE),zero.policy = TRUE)
tabela[3,2]<-round(mod.lag$rho,3)
tabela[3,3]<-round(LR.Sarlm(mod.lag, lm(f, data=parcela_vivas))$p.value[1],3)
tabela[3,4]<-round(mod.lag$LL,3)
tabela[3,5]<-round(AIC(mod.lag),1)
tabela[3,6]<-1-(sum((parcela_vivas$du_annual_growth-(mod.lag$fitted.values))^2)/sum((parcela_vivas$du_annual_growth-mean(parcela_vivas$du_annual_growth))^2))
tabela2[,4]<-round(summary(mod.lag)$Coef[,"Estimate"],4)
tabela2[,5]<-round(summary(mod.lag)$Coef[,"Pr(>|z|)"],4)
mod.lag<-lagsarlm(f,data=parcela_vivas,listw=nb2listw(dnearneigh(parcela_vivas, d1=0, d2=15),zero.policy = TRUE),zero.policy = TRUE)
tabela[4,2]<-round(mod.lag$rho,3)
tabela[4,3]<-round(LR.Sarlm(mod.lag, lm(f, data=parcela_vivas))$p.value[1],3)
tabela[4,4]<-round(mod.lag$LL,3)
tabela[4,5]<-round(AIC(mod.lag),1)
tabela[4,6]<-1-(sum((parcela_vivas$du_annual_growth-(mod.lag$fitted.values))^2)/sum((parcela_vivas$du_annual_growth-mean(parcela_vivas$du_annual_growth))^2))
tabela2[,6]<-round(summary(mod.lag)$Coef[,"Estimate"],4)
tabela2[,7]<-round(summary(mod.lag)$Coef[,"Pr(>|z|)"],4)
mod.lag<-lagsarlm(f,data=parcela_vivas,listw=nb2listw(knn2nb(knearneigh(parcela_vivas, k=4)),style="W"),zero.policy = TRUE)
tabela[5,2]<-round(mod.lag$rho,3)
tabela[5,3]<-round(LR.Sarlm(mod.lag, lm(f, data=parcela_vivas))$p.value[1],3)
tabela[5,4]<-round(mod.lag$LL,3)
tabela[5,5]<-round(AIC(mod.lag),1)
tabela[5,6]<-1-(sum((parcela_vivas$du_annual_growth-(mod.lag$fitted.values))^2)/sum((parcela_vivas$du_annual_growth-mean(parcela_vivas$du_annual_growth))^2))
tabela2[,8]<-round(summary(mod.lag)$Coef[,"Estimate"],4)
tabela2[,9]<-round(summary(mod.lag)$Coef[,"Pr(>|z|)"],4)
mod.lag<-lagsarlm(f,data=parcela_vivas,listw=nb2listw(knn2nb(knearneigh(parcela_vivas, k=8)),style="W"),zero.policy = TRUE)
tabela[6,2]<-round(mod.lag$rho,3)
tabela[6,3]<-round(LR.Sarlm(mod.lag, lm(f, data=parcela_vivas))$p.value[1],3)
tabela[6,4]<-round(mod.lag$LL,3)
tabela[6,5]<-round(AIC(mod.lag),1)
tabela[6,6]<-1-(sum((parcela_vivas$du_annual_growth-(mod.lag$fitted.values))^2)/sum((parcela_vivas$du_annual_growth-mean(parcela_vivas$du_annual_growth))^2))
tabela2[,10]<-round(summary(mod.lag)$Coef[,"Estimate"],4)
tabela2[,11]<-round(summary(mod.lag)$Coef[,"Pr(>|z|)"],4)
mod.lag<-lagsarlm(f,data=parcela_vivas,listw=nb2listw(WW$n,zero.policy=TRUE),zero.policy = TRUE)
tabela[7,2]<-round(mod.lag$rho,1)
tabela[7,3]<-round(LR.Sarlm(mod.lag, lm(f, data=parcela_vivas))$p.value[1],3)
tabela[7,4]<-round(mod.lag$LL,3)
tabela[7,5]<-round(AIC(mod.lag),1)
tabela[7,6]<-1-(sum((parcela_vivas$du_annual_growth-(mod.lag$fitted.values))^2)/sum((parcela_vivas$du_annual_growth-mean(parcela_vivas$du_annual_growth))^2))
tabela2[,12]<-round(summary(mod.lag)$Coef[,"Estimate"],4)
tabela2[,13]<-round(summary(mod.lag)$Coef[,"Pr(>|z|)"],4)
nomes2<-c("Row-normalized","Estimate","p-value","Estimate","p-value","Estimate","p-value","Estimate","p-value","Estimate","p-value","Estimate","p-value");colnames(tabela2)<-nomes2
tabela2

tabela2<-data.frame()
tabela2[1,1]<-"(Intercept)";tabela2[2,1]<-"Cea_0.5m_1px";tabela2[3,1]<-"Cea_1m_1px";tabela2[4,1]<-"Altimetria_1px";
tabela2[5,1]<-"slope_1px";tabela2[6,1]<-"cos_aspect_1px";tabela2[7,1]<-"TRI_1px";tabela2[8,1]<-"TPI_tree_1px";tabela2[9,1]<-"TWI_tree_1px"
mod.lag<-lagsarlm(f,data=parcela_vivas,listw=nb2listwdist(nb2listw(dnearneigh(parcela_vivas, d1=0, d2=8),zero.policy = TRUE)$n,parcela_vivas,type="idw",zero.policy = TRUE),zero.policy = TRUE)
tabela[2,7]<-round(mod.lag$rho,3)
tabela[2,8]<-round(LR.Sarlm(mod.lag, lm(f, data=parcela_vivas))$p.value[1],3)
tabela[2,9]<-round(mod.lag$LL,3)
tabela[2,10]<-round(AIC(mod.lag),1)
tabela[2,11]<-1-(sum((parcela_vivas$du_annual_growth-(mod.lag$fitted.values))^2)/sum((parcela_vivas$du_annual_growth-mean(parcela_vivas$du_annual_growth))^2))
tabela2[,2]<-round(summary(mod.lag)$Coef[,"Estimate"],4)
tabela2[,3]<-round(summary(mod.lag)$Coef[,"Pr(>|z|)"],4)
mod.lag<-lagsarlm(f,data=parcela_vivas,listw=nb2listwdist(nb2listw(dnearneigh(parcela_vivas, d1=0, d2=10),zero.policy = TRUE)$n,parcela_vivas,type="idw",zero.policy = TRUE),zero.policy = TRUE)
tabela[3,7]<-round(mod.lag$rho,3)
tabela[3,8]<-round(LR.Sarlm(mod.lag, lm(f, data=parcela_vivas))$p.value[1],3)
tabela[3,9]<-round(mod.lag$LL,3)
tabela[3,10]<-round(AIC(mod.lag),1)
tabela[3,11]<-1-(sum((parcela_vivas$du_annual_growth-(mod.lag$fitted.values))^2)/sum((parcela_vivas$du_annual_growth-mean(parcela_vivas$du_annual_growth))^2))
tabela2[,4]<-round(summary(mod.lag)$Coef[,"Estimate"],4)
tabela2[,5]<-round(summary(mod.lag)$Coef[,"Pr(>|z|)"],4)
mod.lag<-lagsarlm(f,data=parcela_vivas,listw=nb2listwdist(nb2listw(dnearneigh(parcela_vivas, d1=0, d2=15),zero.policy = TRUE)$n,parcela_vivas,type="idw",zero.policy = TRUE),zero.policy = TRUE)
tabela[4,7]<-round(mod.lag$rho,3)
tabela[4,8]<-round(LR.Sarlm(mod.lag, lm(f, data=parcela_vivas))$p.value[1],3)
tabela[4,9]<-round(mod.lag$LL,3)
tabela[4,10]<-round(AIC(mod.lag),1)
tabela[4,11]<-1-(sum((parcela_vivas$du_annual_growth-(mod.lag$fitted.values))^2)/sum((parcela_vivas$du_annual_growth-mean(parcela_vivas$du_annual_growth))^2))
tabela2[,6]<-round(summary(mod.lag)$Coef[,"Estimate"],4)
tabela2[,7]<-round(summary(mod.lag)$Coef[,"Pr(>|z|)"],4)
mod.lag<-lagsarlm(f,data=parcela_vivas,listw=nb2listwdist(nb2listw(knn2nb(knearneigh(parcela_vivas, k=4)))$n,parcela_vivas,type="idw"),zero.policy = TRUE)
tabela[5,7]<-round(mod.lag$rho,3)
tabela[5,8]<-round(LR.Sarlm(mod.lag, lm(f, data=parcela_vivas))$p.value[1],3)
tabela[5,9]<-round(mod.lag$LL,3)
tabela[5,10]<-round(AIC(mod.lag),1)
tabela[5,11]<-1-(sum((parcela_vivas$du_annual_growth-(mod.lag$fitted.values))^2)/sum((parcela_vivas$du_annual_growth-mean(parcela_vivas$du_annual_growth))^2))
tabela2[,8]<-round(summary(mod.lag)$Coef[,"Estimate"],4)
tabela2[,9]<-round(summary(mod.lag)$Coef[,"Pr(>|z|)"],4)
mod.lag<-lagsarlm(f,data=parcela_vivas,listw=nb2listwdist(nb2listw(knn2nb(knearneigh(parcela_vivas, k=8)))$n,parcela_vivas,type="idw"),zero.policy = TRUE)
tabela[6,7]<-round(mod.lag$rho,3)
tabela[6,8]<-round(LR.Sarlm(mod.lag, lm(f, data=parcela_vivas))$p.value[1],3)
tabela[6,9]<-round(mod.lag$LL,3)
tabela[6,10]<-round(AIC(mod.lag),1)
tabela[6,11]<-1-(sum((parcela_vivas$du_annual_growth-(mod.lag$fitted.values))^2)/sum((parcela_vivas$du_annual_growth-mean(parcela_vivas$du_annual_growth))^2))
tabela2[,10]<-round(summary(mod.lag)$Coef[,"Estimate"],4)
tabela2[,11]<-round(summary(mod.lag)$Coef[,"Pr(>|z|)"],4)
mod.lag<-lagsarlm(f,data=parcela_vivas,listw=Wdist,zero.policy = TRUE)
tabela[7,7]<-round(mod.lag$rho,1)
tabela[7,8]<-round(LR.Sarlm(mod.lag, lm(f, data=parcela_vivas))$p.value[1],3)
tabela[7,9]<-round(mod.lag$LL,3)
tabela[7,10]<-round(AIC(mod.lag),1)
tabela[7,11]<-1-(sum((parcela_vivas$du_annual_growth-(mod.lag$fitted.values))^2)/sum((parcela_vivas$du_annual_growth-mean(parcela_vivas$du_annual_growth))^2))
tabela2[,12]<-round(summary(mod.lag)$Coef[,"Estimate"],4)
tabela2[,13]<-round(summary(mod.lag)$Coef[,"Pr(>|z|)"],4)
nomes2<-c("Inverse Dist","Estimate","p-value","Estimate","p-value","Estimate","p-value","Estimate","p-value","Estimate","p-value","Estimate","p-value");colnames(tabela2)<-nomes2
tabela2

tabela2<-data.frame()
tabela2[1,1]<-"(Intercept)";tabela2[2,1]<-"Cea_0.5m_1px";tabela2[3,1]<-"Cea_1m_1px";tabela2[4,1]<-"Altimetria_1px";
tabela2[5,1]<-"slope_1px";tabela2[6,1]<-"cos_aspect_1px";tabela2[7,1]<-"TRI_1px";tabela2[8,1]<-"TPI_tree_1px";tabela2[9,1]<-"TWI_tree_1px"
mod.lag<-lagsarlm(f,data=parcela_vivas,listw=nb2listw(dnearneigh(parcela_vivas, d1=0, d2=8),zero.policy = TRUE,style="B"),zero.policy = TRUE)
tabela[2,12]<-round(mod.lag$rho,3)
tabela[2,13]<-round(LR.Sarlm(mod.lag, lm(f, data=parcela_vivas))$p.value[1],3)
tabela[2,14]<-round(mod.lag$LL,3)
tabela[2,15]<-round(AIC(mod.lag),1)
tabela[2,16]<-1-(sum((parcela_vivas$du_annual_growth-(mod.lag$fitted.values))^2)/sum((parcela_vivas$du_annual_growth-mean(parcela_vivas$du_annual_growth))^2))
tabela2[,2]<-round(summary(mod.lag)$Coef[,"Estimate"],4)
tabela2[,3]<-round(summary(mod.lag)$Coef[,"Pr(>|z|)"],4)
mod.lag<-lagsarlm(f,data=parcela_vivas,listw=nb2listw(dnearneigh(parcela_vivas, d1=0, d2=10),zero.policy = TRUE,style="B"),zero.policy = TRUE)
tabela[3,12]<-round(mod.lag$rho,3)
tabela[3,13]<-round(LR.Sarlm(mod.lag, lm(f, data=parcela_vivas))$p.value[1],3)
tabela[3,14]<-round(mod.lag$LL,3)
tabela[3,15]<-round(AIC(mod.lag),1)
tabela[3,16]<-1-(sum((parcela_vivas$du_annual_growth-(mod.lag$fitted.values))^2)/sum((parcela_vivas$du_annual_growth-mean(parcela_vivas$du_annual_growth))^2))
tabela2[,4]<-round(summary(mod.lag)$Coef[,"Estimate"],4)
tabela2[,5]<-round(summary(mod.lag)$Coef[,"Pr(>|z|)"],4)
mod.lag<-lagsarlm(f,data=parcela_vivas,listw=nb2listw(dnearneigh(parcela_vivas, d1=0, d2=15),zero.policy = TRUE,style="B"),zero.policy = TRUE)
tabela[4,12]<-round(mod.lag$rho,3)
tabela[4,13]<-round(LR.Sarlm(mod.lag, lm(f, data=parcela_vivas))$p.value[1],3)
tabela[4,14]<-round(mod.lag$LL,3)
tabela[4,15]<-round(AIC(mod.lag),1)
tabela[5,16]<-1-(sum((parcela_vivas$du_annual_growth-(mod.lag$fitted.values))^2)/sum((parcela_vivas$du_annual_growth-mean(parcela_vivas$du_annual_growth))^2))
tabela2[,6]<-round(summary(mod.lag)$Coef[,"Estimate"],4)
tabela2[,7]<-round(summary(mod.lag)$Coef[,"Pr(>|z|)"],4)
mod.lag<-lagsarlm(f,data=parcela_vivas,listw=nb2listw(knn2nb(knearneigh(parcela_vivas, k=4)),style="B"),zero.policy = TRUE)
tabela[5,12]<-round(mod.lag$rho,3)
tabela[5,13]<-round(LR.Sarlm(mod.lag, lm(f, data=parcela_vivas))$p.value[1],3)
tabela[5,14]<-round(mod.lag$LL,3)
tabela[5,15]<-round(AIC(mod.lag),1)
tabela[5,16]<-1-(sum((parcela_vivas$du_annual_growth-(mod.lag$fitted.values))^2)/sum((parcela_vivas$du_annual_growth-mean(parcela_vivas$du_annual_growth))^2))
tabela2[,8]<-round(summary(mod.lag)$Coef[,"Estimate"],4)
tabela2[,9]<-round(summary(mod.lag)$Coef[,"Pr(>|z|)"],4)
mod.lag<-lagsarlm(f,data=parcela_vivas,listw=nb2listw(knn2nb(knearneigh(parcela_vivas, k=8)),style="B"),zero.policy = TRUE)
tabela[6,12]<-round(mod.lag$rho,3)
tabela[6,13]<-round(LR.Sarlm(mod.lag, lm(f, data=parcela_vivas))$p.value[1],3)
tabela[6,14]<-round(mod.lag$LL,3)
tabela[6,15]<-round(AIC(mod.lag),1)
tabela[6,16]<-1-(sum((parcela_vivas$du_annual_growth-(mod.lag$fitted.values))^2)/sum((parcela_vivas$du_annual_growth-mean(parcela_vivas$du_annual_growth))^2))
tabela2[,10]<-round(summary(mod.lag)$Coef[,"Estimate"],4)
tabela2[,11]<-round(summary(mod.lag)$Coef[,"Pr(>|z|)"],4)
mod.lag<-lagsarlm(f,data=parcela_vivas,listw=W,zero.policy = TRUE)
tabela[7,12]<-round(mod.lag$rho,1)
tabela[7,13]<-round(LR.Sarlm(mod.lag, lm(f, data=parcela_vivas))$p.value[1],3)
tabela[7,14]<-round(mod.lag$LL,3)
tabela[7,15]<-round(AIC(mod.lag),1)
tabela[7,16]<-1-(sum((parcela_vivas$du_annual_growth-(mod.lag$fitted.values))^2)/sum((parcela_vivas$du_annual_growth-mean(parcela_vivas$du_annual_growth))^2))
tabela2[,12]<-round(summary(mod.lag)$Coef[,"Estimate"],4)
tabela2[,13]<-round(summary(mod.lag)$Coef[,"Pr(>|z|)"],4)
nomes2<-c("Binary","Estimate","p-value","Estimate","p-value","Estimate","p-value","Estimate","p-value","Estimate","p-value","Estimate","p-value");colnames(tabela2)<-nomes2
tabela2
nomes<-c("","Row-normalized","","","","","Inverse Distance","","","","","Binary","","","","");colnames(tabela)<-nomes
tabela
#tabela_spatial_lag_A<-tabela
#tabela_spatial_lag_B<-tabela
#tabela_spatial_lag_C<-tabela
#tabela_spatial_lag_D<-tabela


##3.3.3.2  #Fitting spatial models for obtaining results
########
# (Again) Spatial modelling consisting in fitting the spatial lag model (check rho parameter), spatial error (check lambda parameter) and if needed SAC model (rho and lambda)
# This phase is for a complementar phase of the outputs generated before. The model errors are evaluated.
#For this the code from MLC - has the advantage of being more versatile and fast, to check smaller variations that can be applied to the model.

# Analyze effect of interaction
# Compare response witout spatial autocorrelation (Y0) and response when spatial autocorrelation occurs (YA)

# lista para guardar resultados:
RESULTS=list()
# ciclo para passar pelos sites e pelo nÃºmero de vizinhos
for (SITE in LETTERS[1:4]) # "A") #
  for (K in 8:8) # 
  {
    print(paste(K,SITE))
    
    results=list()
        
    DF=read.csv2("C:/Users/caven/Google Drive (paulofirmino@e-isa.ulisboa.pt)/2023-Doutoramento/SpatialCorkoak/Dados_SpatialCorkOak.csv",header=TRUE,sep=";",dec = ",")
    head(DF)
    dim(DF)
    YA=DF$du #du_annual_growth #
    mort=DF$Morta
    x=DF$coordsX
    y=DF$coordsY
    mais_velha=DF$mais_velha
    sites=DF$Site
    # "probmort"
    vars=c("Cea_1m_1px","Cea_0.5m_1px","Altimetria_1px","slope_1px","TPI_tree_1px","TWI_tree_1px","TRI_1px","cos_aspect_1px")
    results$vars=vars
    
    # select data depending on cond
    cond=(sites==SITE & mort==0 & mais_velha==0 & YA>=0)
    n=sum(cond)
    YA=YA[cond] # has columns X1,..., and Y
    x=x[cond] # has columns X1,..., and Y
    y=y[cond] # has columns X1,..., and Y
    DF=DF[cond,]
    dfxy=cbind(data.frame(x,y),DF[,vars])
    df=dfxy
    df$x=NULL
    df$y=NULL
    coordinates(dfxy)=c("x","y") # dfxy is a sp object
    
    # scale response variable
    #df$Y=scale(YA)
    head(df)
    
    # nlist
    # to avoid empty neighborhoods
    set.ZeroPolicyOption(TRUE)
    get.ZeroPolicyOption()
     #nlist=spdep::dnearneigh(dfxy,d1=0,d2=K) # problems with empty neighborhoods
     nlist=spdep::knn2nb(knearneigh(dfxy,k=K))

    ############################################################# analize data set
    if (FALSE)
    {
      # estimate rho (lento)
      lagsarlm(Y~.,data=df,listw=nb2listw(nlist,style="W",zero.policy = TRUE))$rho
      # estimate lambda
      errorsarlm(Y~.,data=df,listw=nb2listw(nlist,style="W",zero.policy = TRUE))$lambda
    }
    
    # plot values
    plot(dfxy$x,dfxy$y,pch='.') # locations (x,y)
    text(dfxy$x,dfxy$y,label=round(YA,2),cex=0.5) # locations (x,y)
    
    # distance based (1 connection is 1 unit) Moran's I
    #plot(sp.correlogram(nlist,as.vector(YA),order=10,method="I",style="W"))
    plot(sp.correlogram(nlist,as.vector(YA),order=5,method="I",style="W"))
    # variogram
    dfxy$Y=YA
    myvgm=variogram(YA~1, dfxy)
    plot(myvgm)
    mymodel <- gstat::fit.variogram(myvgm,vgm("Sph"),fit.kappa=TRUE)
    plot(myvgm, model=mymodel)
    
    ############################################################## fit models
    
    # use a model that doesn't "model" autocorrelation (regular linear model)
    df$Y=YA
    model=lm(Y~.,data=df)
    summary(model)
    Ypred=fitted(model)
    plot(Ypred~YA)
    results$lrr2=paste('LR R2=',1-sum((Ypred-YA)^2)/(var(YA)*(n-1)))
    
    # lagmodel 
    df$Y=YA
    model=lagsarlm(Y~.,data=df,listw=nb2listw(nlist,style="W",zero.policy = TRUE))
    summary(model)
    Ypred=fitted(model)
    plot(Ypred~YA)
    results$lagr2=paste('lagmodel R2=',1-sum((Ypred-YA)^2)/(var(YA)*(n-1)))
    
    # spatial error model 
    df$Y=YA
    model=errorsarlm(Y~.,data=df,listw=nb2listw(nlist,style="W",zero.policy = TRUE))
    summary(model)
    Ypred=fitted(model)
    plot(Ypred~YA)
    results$errr2=paste('spatial error model R2=',1-sum((Ypred-YA)^2)/(var(YA)*(n-1)))
    
    # both
    df$Y=YA
    model=sacsarlm(Y~.,data=df,listw=nb2listw(nlist, style="W",zero.policy = TRUE))
    summary(model)
    Ypred=fitted(model)
    plot(Ypred~YA)
    results$sac2=paste('spatial sac model R2=',1-sum((Ypred-YA)^2)/(var(YA)*(n-1)))
    
    # compare models with spdep::lm.LMtests
    # Lagrange multiplier diagnostics for spatial dependence (pg 435)
    model=lm(YA~.,data=df)
    res=spdep::lm.LMtests(model,nb2listw(nlist,style="W",zero.policy = TRUE),test="all")
    for (mod in c("LMerr",  "LMlag",  "RLMerr", "RLMlag" ,"SARMA")) results[[mod]]=res[[mod]]$p.value
    
    # atualizar lista de resultados
    RESULTS[[paste(SITE,K)]]=results
  }
results

######
#Evaluation: 
#Model results from PNF code and MLC match.
#AIC, R2 parameters have some differences between the spatial proximity choice/spatial weights
#Estimates of variables/p-values are mostly similar for all models, with slight variations on the site with less spatial autocorrelation
#Rho and Lambda are higher in spatial lags/spatial models for greater distances (10 and 15m) on row-normalized weights and the opposite on the idw weights, as expected
#Best spatial weights are consistently the row-normalized. Best spatial proximity method is varies in Spatial lag/spatial errors models, but is consistent on the SAC - 10m distance
########
