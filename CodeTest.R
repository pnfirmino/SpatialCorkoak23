library(sf)
library(spdep)
library(whitebox)
library(car)
ibrary(spatialreg)
library(gstat)

###############################
###Section 1 - Data preparation and variable calculation
###############################
#Upload and prepare data file
Dados_SpatialCorkOak_9_maio_23 <- read_excel("/path/Dados_SpatialCorkOak_9_maio_23.xlsx")
Dados_SpatialCorkoak1<-st_as_sf(Dados_SpatialCorkoak1, coords=c("coordsX","coordsY"))
parcela<-Dados_SpatialCorkOak1[which(Dados_SpatialCorkOak1$Site == "A"),] ## Select on of the 4 properties (A, B, C, D) - A and B are SantarÃ©m, C and D are Castelo Branco 
parcela_vivas<-parcela[which(parcela$mais_velha == 0),]  ##Remove clearly older trees present in the plantation area


##1. Variable calculation - Dependent and independent variables
#1.1 - Independent Variables (Cea_1m ; Cea_0.5m; Elev; slope; cos_aspect;TRI ;TPI; TWI)
# these variable are already calculated on the sf object. Code displayed in this section is only for informative purposes

#1.1.1 Geographical position indices calculation (TPI and TRI)
f <- matrix(1, nrow=5, ncol=5)
TPI <- focal(Altimetria, w=f, fun=function(x, ...) x[5] - mean(x[-5]), pad=TRUE, padValue=NA)
plot(TPI)
TRI <- focal(Altimetria, w=f, fun=function(x) sum(abs(x[-5]-x[5]))/8, pad=TRUE, padValue=NA)
plot(TRI)

#1.1.2 Geographical position indices calculation (TWI)
# TWI calculation based on the methodology of https://vt-hydroinformatics.github.io/rgeoraster.html
  # Prepare DEM for Hydrology Analyses
  wbt_breach_depressions_least_cost(
  dem = "/path/parcela_Altimetria.tif",
  output = "/path/parcela_DTM_breach.tif",
  dist = 5,
  fill = TRUE)
  # wbt_fill_depressions_wang_and_liu(
  dem = "/path/parcela_DTM_breach.tif",
  output = "/path/parcela_DTM_breach_fill.tif",
  )
  # Visualize and correct filled sinks and breached depression
  filled_breached <- raster(/path/"parcela_DTM_breach_fill.tif")
  plot(filled_breached)
    difference <- Altimetria - filled_breached
  difference[difference == 0] <- NA
  #D infinity flow accumulation (alternative flow accumulation may be calculated from D infinity method D8 Flow Accumulation)
  wbt_d_inf_flow_accumulation("/path/parcela_DTM_breach_fill.tif",
                              "/path/Infinit_FlowAccum.tif")
  dinf <- raster("/path/Infinit_FlowAccum.tif")
  plot(dinf)
  #Calculate Specific Contributing Area
  wbt_d_inf_flow_accumulation(input = "/path/parcela_DTM_breach_fill.tif",
                            output = "/path/FlowAccum2.tif",
                            out_type = "Specific Contributing Area")
  #Calculate slope or use slope mapped tif from data
  wbt_slope(dem = "/path/parcela_DTM_breach_fill.tif",
          output = "/path/parcela_slope_degrees.tif",
          units = "degrees")
  #Calculate topographic wetness index
  wbt_wetness_index(sca = "/path/FlowAccum2.tif",
                  slope = "/path/parcela_slope_degrees.tif",
                  output = "/path/TWI.tif")
  twi <- raster("/path/TWI.tif")
  plot(twi)

########
#1.2 Dependent variables - Calculate diameter related variables and attribute explanatory values to points

# Dependent variable is considered in the ways: 1) as the individual diameter annual growth; 2) as the basal area annual growth of a group of closely located trees
#Annual growth is considered so that all plots are normalized by age
########
#1.2.1 - Individual diameter annual growth
#Already calculated in dataframe as column "du_annual_growth"          
#Attribute exploratory variable value according to the pixel where tree is positioned
parcela$Cea_1m_1px<-extract(Cea_1m,parcela) #Variable Example, already on the dataframe
             
########
#1.2.2 - Basal area annual growth of a group of closely located trees
parcela$BA<-pi*(parcela$du^2)/4      #Individual tree basal area
parcela$annual_BA<-(pi*(parcela$du^2)/4)/parcela$t  #Annual growth in individual tree basal area (BA/t).
       
             
#Requires the definition of the tree groups. Tree may be grouped by a fixed number of individuals or by a fixed area
#1.2.2.1 # Definition of groups according to the 8 closest neighbours to a subject tree.
             
#Order the dataframe by tree coordinates. This is required to produce the best results in grouping, avoiding huge polygon when few individuals are still available.        
par<- parcela
xy = st_coordinates(par)
par = par[order(xy[,"X"], xy[,"Y"]),] #produces a modified sf object (ordered coordinates) to use for this part

polygon_list <- list() #prepares empty objects to be used on the cycle
combined_pol <- st_polygon()
arvores<-dataframe()

#Cycle to create polygons representing the groups. Output generated by cycle:
  #1) "arvores" object, with the dataframe of tree groups, with basal area and independent variables    
  #2) "polygon_list", with the polygons representing the groups of trees
# Cycle works by selecting one tree and its 8 closests neighbours, and treats them as a unit
    #Dependent value is the sum of the 9 trees. Independent variables are the mean of the 9 trees pixel values
    #A polygon is generated containing all 9 points, to represent the unit in plots
    #The used point are removed so they are no considered in the next loop
    #cycle has 235 loop, but it actually end in the error message "not enough trees to continue". The number of loops until the error depend on the site.
    #Cycle is slow, each loop is faster as the dataframe is continuously smaller
             
for(i in c(1:235)) {
  #Create empty objects the neighbour selection. This must be cleared at the beginning at each loop
  arvsuj <- data.frame(matrix(NA,  ncol = dim(parcela)[2]))
  arv1 <- data.frame(matrix(NA,  ncol = dim(parcela)[2]))
  arv2 <- data.frame(matrix(NA,  ncol = dim(parcela)[2]))
  arv3 <- data.frame(matrix(NA,  ncol = dim(parcela)[2]))
  arv4 <- data.frame(matrix(NA,  ncol = dim(parcela)[2]))
  arv5 <- data.frame(matrix(NA,  ncol = dim(parcela)[2]))
  arv6 <- data.frame(matrix(NA,  ncol = dim(parcela)[2]))
  arv7 <- data.frame(matrix(NA,  ncol = dim(parcela)[2]))
  arv8 <- data.frame(matrix(NA,  ncol = dim(parcela)[2]))

  #Assing subject tree and 8 neighbours.
  par$continId<-c(1:dim(par)[1])  #ContinId must be re-generated each loop and will crash, as it is not continuous id after removing elements from dataframe
  arvsuj[1,]<-par[1,]
  arv1[1,]<-(par[which(par$continId == ((knearneigh(par, k=8)$nn[1,1]))),])
  arv2[1,]<-(par[which(par$continId == ((knearneigh(par, k=8)$nn[1,2]))),])
  arv3[1,]<-(par[which(par$continId == ((knearneigh(par, k=8)$nn[1,3]))),])
  arv4[1,]<-(par[which(par$continId == ((knearneigh(par, k=8)$nn[1,4]))),])
  arv5[1,]<-(par[which(par$continId == ((knearneigh(par, k=8)$nn[1,5]))),])
  arv6[1,]<-(par[which(par$continId == ((knearneigh(par, k=8)$nn[1,6]))),])
  arv7[1,]<-(par[which(par$continId == ((knearneigh(par, k=8)$nn[1,7]))),])
  arv8[1,]<-(par[which(par$continId == ((knearneigh(par, k=8)$nn[1,8]))),])
  colnames(arvsuj)<-colnames(arv1)<-colnames(arv2)<-colnames(arv3)<-colnames(arv4)<-colnames(arv5)<-colnames(arv6)<-colnames(arv7)<-colnames(arv8)<-colnames(par)             

  #Remove subject tree and 8 neighbours from dataframe
  par<-par[-which(par$continId == arvsuj[1,"continId"]),]
  par<-par[-which(par$continId == arv1[1,"continId"]),]
  par<-par[-which(par$continId == arv2[1,"continId"]),]
  par<-par[-which(par$continId == arv3[1,"continId"]),]
  par<-par[-which(par$continId == arv4[1,"continId"]),]
  par<-par[-which(par$continId == arv5[1,"continId"]),]
  par<-par[-which(par$continId == arv6[1,"continId"]),]
  par<-par[-which(par$continId == arv7[1,"continId"]),]
  par<-par[-which(par$continId == arv8[1,"continId"]),]

  #Create new dataframe, with the dependent and independent variables from the group unit
  b<-data.frame(matrix(NA,  ncol = 1))
  b$id<- arvsuj[1,"id"]
  b$continId<-arvsuj[1,"continId"]
  b$BA<-arvsuj[1,"annual_BA"]+arv1[1,"annual_BA"]+arv2[1,"annual_BA"]+arv3[1,"annual_BA"]+arv4[1,"annual_BA"]+arv5[1,"annual_BA"]+arv6[1,"annual_BA"]+arv7[1,"annual_BA"]+ arv8[1,"annual_BA"]
  b$CEa_0.5<-(arvsuj[1,"Cea_0.5m_1px"]+arv1[1,"Cea_0.5m_1px"]+arv2[1,"Cea_0.5m_1px"]+arv3[1,"Cea_0.5m_1px"]+
                arv4[1,"Cea_0.5m_1px"]+arv5[1,"Cea_0.5m_1px"]+arv6[1,"Cea_0.5m_1px"]+arv7[1,"Cea_0.5m_1px"]+
                arv8[1,"Cea_0.5m_1px"]/9)
  b$CEa_1<-((arvsuj[1,"Cea_1m_1px"]+arv1[1,"Cea_1m_1px"]+arv2[1,"Cea_1m_1px"]+arv3[1,"Cea_1m_1px"]+
               arv4[1,"Cea_1m_1px"]+arv5[1,"Cea_1m_1px"]+arv6[1,"Cea_1m_1px"]+arv7[1,"Cea_1m_1px"]+
               arv8[1,"Cea_1m_1px"])/9)
  b$TRI<-((arvsuj[1,"TRI_1px"]+arv1[1,"TRI_1px"]+arv2[1,"TRI_1px"]+arv3[1,"TRI_1px"]+
             arv4[1,"TRI_1px"]+arv5[1,"TRI_1px"]+arv6[1,"TRI_1px"]+arv7[1,"TRI_1px"]+
             arv8[1,"TRI_1px"])/9)
  b$TPI<-((arvsuj[1,"TPI_1px"]+arv1[1,"TPI_1px"]+arv2[1,"TPI_1px"]+arv3[1,"TPI_1px"]+
             arv4[1,"TPI_1px"]+arv5[1,"TPI_1px"]+arv6[1,"TPI_1px"]+arv7[1,"TPI_1px"]+
             arv8[1,"TPI_1px"])/9)
  b$slope<-((arvsuj[1,"slope_1px"]+arv1[1,"slope_1px"]+arv2[1,"slope_1px"]+arv3[1,"slope_1px"]+
               arv4[1,"slope_1px"]+arv5[1,"slope_1px"]+arv6[1,"slope_1px"]+arv7[1,"slope_1px"]+
               arv8[1,"slope_1px"])/9)
  b$cos_asp<-((arvsuj[1,"cos_aspect_1px"]+arv1[1,"cos_aspect_1px"]+arv2[1,"cos_aspect_1px"]+arv3[1,"cos_aspect_1px"]+
                 arv4[1,"cos_aspect_1px"]+arv5[1,"cos_aspect_1px"]+arv6[1,"cos_aspect_1px"]+arv7[1,"cos_aspect_1px"]+
                 arv8[1,"cos_aspect_1px"])/9)
  b$Elev<-((arvsuj[1,"Elev_1px"]+arv1[1,"Elev_1px"]+arv2[1,"Elev_1px"]+arv3[1,"Elev_1px"]+
              arv4[1,"Elev_1px"]+arv5[1,"Elev_1px"]+arv6[1,"Elev_1px"]+arv7[1,"Elev_1px"]+
              arv8[1,"Elev_1px"])/9)
  b$TWI<-((arvsuj[1,"TWI_1px"]+arv1[1,"TWI_1px"]+arv2[1,"TWI_1px"]+arv3[1,"TWI_1px"]+
             arv4[1,"TWI_1px"]+arv5[1,"TWI_1px"]+arv6[1,"TWI_1px"]+arv7[1,"TWI_1px"]+
             arv8[1,"TWI_1px"])/9)
  b$geometry<-arvsuj[1,"geometry"]
  b<-b[,-1]  #removes the useless NA col
  arvores<-rbind(arvores,b) #stores each line on the object arvores

  #Creates a polygon that overlays all 9 points
  arv_neigh<-rbind(arvsuj[1,],arv1[1,],arv2[1,],arv3[1,],arv4[1,],arv5[1,],arv6[1,],arv7[1,],arv8[1,])
  arv_neigh<-st_as_sf(arv_neigh)
  st_crs(arv_neigh)<-st_crs(parcela)
  points_matrix <- as.matrix(st_coordinates(arv_neigh))
  hull_indices <- chull(points_matrix) #creates a convex hull
  convex_hull_points <- points_matrix[hull_indices, ]
  convex_hull_points <- rbind(convex_hull_points, convex_hull_points[1, ]) #Requires to add again the first point or the polygon will not close
  polygon <- st_polygon(list(convex_hull_points)) #completes the polygon
  polygon_list[[i]]<- polygon #stores to polygon on the polygon_list object
  print(i)  #prints at which loop it is
}
#Prepares to plot all the polygons
combined_polygon <- st_sfc(polygon_list)
combined_polygon <- combined_polygon[!st_is_empty(combined_polygon),drop=FALSE] #removes any generated empty geometry
#combined_polygon$area<-st_area(combined_polygon);combined_polygon<-combined_polygon[which(combined_polygon$area < 200)] #area may be used to remove huge polygon, not used in this version
#Plot points and polygons
plot(parcela["Site"])
plot(combined_polygon,col=rainbow(length(combined_polygon)),add=TRUE)
graph<-(ggplot() +  geom_sf(data = combined_polygon, col="darkgreen",fill="orange",size=1.2)+ geom_point(data = parcela, aes(x = st_coordinates(parcela)[,1], y = st_coordinates(parcela)[,2])))
graph

######
#Evaluation:
#Method creates mostly similar polygon sizes, as much as the plantation spacial allows.
#The plots seem to be well represented by the polygons, which are now independent of each other
#Each polygon has the same number of trees, which makes a fair comparison using the sum of basal area  
                      
#1.2.2.2 # Definition of groups according fixed sized area. *Only informative purpose*
#Cell size was tried for combinations 10x8, 16x8, 20x10, 20x15, 20x20, depending on tree spacing. Idea is to have similar number of trees per unit: 4-6 ; 7-9; 9-12.    

#Sets a grid with custom size, to "cut" the are in units. Cycle output is multiply polygons object "a_parc", with values of the dependent and independent variables    
grid1<-st_make_grid(parcela, cellsize=c(15,20))
a_parc<-st_sf(st_sfc()) #create new empty object to fill by the cycle
            
for(i in c(1:length(grid1))) {
  pol<-st_crop(parcela, grid1[i])  #for each gridded unit, cuts a part of the area and gives variable values to each polygon
  pol2<-length(pol$id) #number of trees per unit
  pol3<-sum(pol$annual_BA)
  pol4<-mean(pol$Cea_0.5m_1px)
  pol5<-mean(pol$Cea_1m_1px)
  pol6<-mean(pol$slope_1px)
  pol7<-mean(pol$Elev_1px)
  pol8<-mean(pol$TRI_1px)
  pol9<-mean(pol$TPI_1px)
  pol10<-mean(pol$cos_aspect_1px)
  pol11<-mean(pol$TWI_1px)
  
  a_parc[i,]<-merge(grid1[i],pol3) #store values of each unit on sf empty object
  a_parc[i,2]<-pol2
  a_parc[i,3]<-pol3
  a_parc[i,4]<-pol4
  a_parc[i,5]<-pol5
  a_parc[i,6]<-pol6
  a_parc[i,7]<-pol7
  a_parc[i,8]<-pol8
  a_parc[i,9]<-pol9
  a_parc[i,10]<-pol10
  a_parc[i,11]<-pol11
}
a_parc<-na.omit(a_parc) 
st_geometry(a_parc)<-(a_parc[,1])
nomes<-c("st_sfc..","Tree_Count","BA","Cea_0.5m","Cea_1m","slope","Elev","TRI","TPI","cos_asp","TWI");colnames(a_parc)<-nomes
plot(a_parc["Tree_Count"],main="Tree_Count")
a_parc$BA<-as.numeric(a_parc$BA);plot(a_parc["BA"],main="Tree_BA")

######
#Evaluation:
#Method creates identical polygon sizes, independent of the plantation spacing           
#The plots are fully represented by the polygons, which are now independent of each other
#The number of trees inside polygons varies, and does not allow a correct usage of the sum of basal area. The alternative would have to be the mean of basal area.

##################################################################################################################################
#### Group definition method selection according to results plot representation, consistency of size and number of tree per polygon           
#Definition of groups according to the 8 closest neighbours to a subject tree is selected to modelling phase.



             
###############################
##2. Spatial autocorrelation analysis
###############################
#Section 2 - Spatial autocorrelation analysis
#Spatial autocorrelation analysis is applied to each plot separately, with the following steps: 
#1) Spatial matrix definition;
#2) Spatial weights definition; 
#3) Global Moran's I analysis
#4) Correlogram (Moran's I statistics) analysis
#5) Local Moran's I analysis
             
########
##2.1 Spatial matrix definition
########             
#Although plantations are regular, trees are not at exact distances to make preferable the using of polygons for analysis.
#Its opted using points for the analysis. Output of 2.1 is nb object.
#Three methods are tested to choice the proper spatial matrix 
#1) Distance based neighbours; k neighbours; Tree area of influence sobreposition
#2.1.1 Distance base neighbours nb objects creation - Selected 8, 10 and 15m. The idea is capture links according to plantation spacing
dnearneigh(parcela_vivas, d1=0, d2=8)
dnearneigh(parcela_vivas, d1=0, d2=10)
dnearneigh(parcela_vivas, d1=0, d2=15)
#2.1.2 k neighbours - Selected 4 and 8 neighbours.
knn2nb(knearneigh(parcela_vivas, k=4))
knn2nb(knearneigh(parcela_vivas, k=8))
#2.1.3  Tree area of influence sobreposition
#Requires 3 steps: 
#1)Calculating individual tree area of influence;
#2)Creating of neighbour/distance table; 
#3)Identifying the trees with sobreposed areas of influence and providing a value for them as neighbours

#2.1.3.1  Calculating individual tree area of influence, according Paulo et al. 2016
parcela_vivas$du_dug<-""
parcela_vivas$du_dug<-parcela_vivas$du/(sqrt(sum((parcela_vivas$du)^2)/length(parcela_vivas$du)))
parcela_vivas$du_dug<-as.numeric(parcela_vivas$du_dug)
parcela_vivas$influence_area_est<-2.5*(28.502*exp((-66.436+4.201*(parcela_vivas$du_dug))/(19.817+parcela_vivas$du))/2) 
plot(parcela_vivas["influence_area_est"],pch=16)

#2.1.3.2 Creating of neighbour/distance table; 
xy<-st_coordinates(parcela_vivas)
matrix<-as.matrix(dist(xy, "euclidean"), labels=TRUE) #Distance matrix
colnames(matrix) <- rownames(matrix) <- parcela_vivas$continId #Name rows and columns
melt <- melt(matrix) #unmaked the matrix to columns
M101<-data.frame(parcela_vivas)
melt_0<-melt[which(melt$value!=0),]  #removes the distances=zero
submelt01<-melt[melt_0$Var1 %in% M101$continId & melt_0$Var2 %in% M101$continId,] #creates a table with Var1, Var2 and the distance value between then
submelt01<-submelt01[which(submelt01$value<33),] #Removes any lines with distace > 33m, which is the highest distance between two neighbouring trees. This condition fastens the process.
submelt01<-submelt01[which(submelt01$value!=0),] #Removes distances =0
mt<-merge(submelt01, M101[,c("continId","influence_area_est" )], by.x="Var1", by.y="continId") #Creates a diameter column for Var1, depending on tree number
mtt<-merge(mt, M101[,c("continId","influence_area_est" )], by.x="Var2", by.y="continId") #Creates a diameter column for Var2, depending on tree number
names(mtt)<-c(names(mtt)[1:3], "influence_area_est2",  "influence_area_est1") #change the names of the two new columns
head(mtt)

#2.1.3.3 Identifying the trees with sobreposed areas of influence and providing a value for them as neighbours
matrix<-matrix(nrow=length(parcela_vivas), ncol=length(parcela_vivas)) #starts a blank matrix for the cycle
for (k in c(1:nrow(mtt))){ 
  valor1<-mtt[k,1]
  valor2<-mtt[k,2]
  linha<- mtt[k,]
  matrix[valor1,valor2]<- ifelse((linha$influence_area_est1 + linha$influence_area_est2 > linha$value),1,0)
}
#asks if the sum of radius of area of influence of two trees is higher than their distance. 
#If true, they are neighbours. The value attributed if neighbours can work as a weight. In this case is 1, similar to binary case.

matrix[is.na(matrix)] = 0 #turns NA to zeros
colnames(matrix) <- rownames(matrix) <- parcela_vivas$continId #give names to new matrix
View(matrix) #check if result is correct
W<- mat2listw(matrix) #creates a listw object from this matrix, ready to be applied.

####2.1.4  Plot and compare results
par(mfrow=c(2,3));par(cex=0.4, pch=16)
plot(dnearneigh(parcela_vivas, d1=0, d2=8), coord=(parcela_vivas$geometry), col="red");title(main=paste("Distance based neighbours - 8m"),cex.main=2)
plot(dnearneigh(parcela_vivas, d1=0, d2=10), coord=(parcela_vivas$geometry), col="red");title(main=paste("Distance based neighbours -10m"),cex.main=2)
plot(dnearneigh(parcela_vivas, d1=0, d2=15), coord=(parcela_vivas$geometry), col="red");title(main=paste("Distance based neighbours - 15m"),cex.main=2)
plot(knn2nb(knearneigh(parcela_vivas, k=4)), coord=(parcela_vivas$geometry), col="red");title(main=paste("k neighbours - 4"),cex.main=2)
plot(knn2nb(knearneigh(parcela_vivas, k=8)), coord=(parcela_vivas$geometry), col="red");title(main=paste("k neighbours - 8"),cex.main=2)
plot(W,coord=(parcela_vivas$geometry),col="red"); title(main=paste("Area of Influence approach"),cex.main=2)

######
#Evaluation: 
#8m distance and k=4 neighbours seem to underestimate the amount of links per tree
#15m distance seems to overestimate the amount of links per tree    
#10 distance and k=8 seem to have a most realistic number and distribution of neighbours
#Area of Influence approach seems to work better on site A and B, where tree size is more regular
#Area of Influence approach may overestimate the neighbours in larger trees
#Area of Influence approach underestimate spatial autocorrelation in very small trees (very few or no neighbours) in C and D
########

             
##2.1.2 Spatial weights matrix definition
########    
##Three methods are tested to choose weights: 1) row-normalized (W); 2) Binary (B); Inverse of distance (idw)
#The three methods generate distinct spatial weight matrices, an object class listw
#Example of a previously defined nb object
nb2listw(dnearneigh(parcela_vivas, d1=0, d2=8),zero.policy = TRUE, style="W") #row-normalized
nb2listw(dnearneigh(parcela_vivas, d1=0, d2=8),zero.policy = TRUE,style="B") #binary
nb2listwdist(nb2listw(dnearneigh(parcela_vivas, d1=0, d2=8),zero.policy = TRUE) #idw        

#To select the most suitable weights, they are compared on the following spatial analysis functions

########
##2.2 Global Moran'I test
########  
# A table can be created fro each plot to compare the multiple methods outputs: Morans'I statistic and respective p-value.
#Example of the output table, plot A:
#                         Weights    Row-normalized          Inverse Distance                    Binary        
#                          Method Moran I statistic p-value Moran I statistic p-value Moran I statistic p-value
#  Distance based neighbours - 8m              0.16       0             0.187       0             0.145       0
# Distance based neighbours - 10m             0.129       0             0.154       0              0.12       0
# Distance based neighbours - 15m             0.129       0             0.136       0             0.112       0
#                k neighbours - 4             0.158       0             0.193       0             0.158       0
#                k neighbours - 8             0.127       0             0.156       0             0.127       0
#      Area of Influence approach              0.07   4e-05             0.102       0             0.103       0


tabela<-data.frame()
tabela[1,1]<- "Method"
tabela[2,1]<- "Distance based neighbours - 8m"
tabela[3,1]<- "Distance based neighbours - 10m"
tabela[4,1]<- "Distance based neighbours - 15m"
tabela[5,1]<- " k neighbours - 4"
tabela[6,1]<- " k neighbours - 8"
tabela[7,1]<- "Area of Influence approach"
tabela[1,2]<-"Moran I statistic";tabela[1,3]<-"p-value";tabela[1,4]<-"Moran I statistic";tabela[1,5]<-"p-value";tabela[1,6]<-"Moran I statistic";tabela[1,7]<-"p-value";
#distance base tests - row-normalized weights; zero.policy=TRUE must be present since there is always points with no (living) neighbours
tabela[2,2]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(dnearneigh(parcela_vivas, d1=0, d2=8),zero.policy = TRUE),zero.policy=TRUE)$estimate[1],3)
tabela[2,3]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(dnearneigh(parcela_vivas, d1=0, d2=8),zero.policy = TRUE),zero.policy=TRUE)$p.value,5)
tabela[3,2]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(dnearneigh(parcela_vivas, d1=0, d2=10),zero.policy = TRUE),zero.policy=TRUE)$estimate[1],3)
tabela[3,3]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(dnearneigh(parcela_vivas, d1=0, d2=10),zero.policy = TRUE),zero.policy=TRUE)$p.value,5)
tabela[4,2]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(dnearneigh(parcela_vivas, d1=0, d2=15),zero.policy = TRUE),zero.policy=TRUE)$estimate[1],3)
tabela[4,3]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(dnearneigh(parcela_vivas, d1=0, d2=15),zero.policy = TRUE),zero.policy=TRUE)$p.value,5)
#distance base tests - inverse of distance weights; can be used nb2listwdist function
tabela[2,4]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listwdist(nb2listw(dnearneigh(parcela_vivas, d1=0, d2=8),zero.policy = TRUE)$n,parcela_vivas,type="idw",zero.policy = TRUE),zero.policy=TRUE)$estimate[1],3)
tabela[2,5]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listwdist(nb2listw(dnearneigh(parcela_vivas, d1=0, d2=8),zero.policy = TRUE)$n,parcela_vivas,type="idw",zero.policy = TRUE),zero.policy=TRUE)$p.value,5)
tabela[3,4]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listwdist(nb2listw(dnearneigh(parcela_vivas, d1=0, d2=10),zero.policy = TRUE)$n,parcela_vivas,type="idw",zero.policy = TRUE),zero.policy=TRUE)$estimate[1],3)
tabela[3,5]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listwdist(nb2listw(dnearneigh(parcela_vivas, d1=0, d2=10),zero.policy = TRUE)$n,parcela_vivas,type="idw",zero.policy = TRUE),zero.policy=TRUE)$p.value,5)
tabela[4,4]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listwdist(nb2listw(dnearneigh(parcela_vivas, d1=0, d2=15),zero.policy = TRUE)$n,parcela_vivas,type="idw",zero.policy = TRUE),zero.policy=TRUE)$estimate[1],3)
tabela[4,5]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listwdist(nb2listw(dnearneigh(parcela_vivas, d1=0, d2=15),zero.policy = TRUE)$n,parcela_vivas,type="idw",zero.policy = TRUE),zero.policy=TRUE)$p.value,5)
#distance base tests - binary weights
tabela[2,6]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(dnearneigh(parcela_vivas, d1=0, d2=8),zero.policy = TRUE,style="B"),zero.policy=TRUE)$estimate[1],3)
tabela[2,7]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(dnearneigh(parcela_vivas, d1=0, d2=8),zero.policy = TRUE,style="B"),zero.policy=TRUE)$p.value,5)
tabela[3,6]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(dnearneigh(parcela_vivas, d1=0, d2=10),zero.policy = TRUE,style="B"),zero.policy=TRUE)$estimate[1],3)
tabela[3,7]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(dnearneigh(parcela_vivas, d1=0, d2=10),zero.policy = TRUE,style="B"),zero.policy=TRUE)$p.value,5)
tabela[4,6]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(dnearneigh(parcela_vivas, d1=0, d2=15),zero.policy = TRUE,style="B"),zero.policy=TRUE)$estimate[1],3)
tabela[4,7]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(dnearneigh(parcela_vivas, d1=0, d2=15),zero.policy = TRUE,style="B"),zero.policy=TRUE)$p.value,5)
#k neighbours - row-normalized weights
tabela[5,2]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(knn2nb(knearneigh(parcela_vivas, k=4)),style="W"),zero.policy=TRUE)$estimate[1],3)
tabela[5,3]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(knn2nb(knearneigh(parcela_vivas, k=4)),style="W"),zero.policy=TRUE)$p.value,5)
tabela[6,2]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(knn2nb(knearneigh(parcela_vivas, k=8)),style="W"),zero.policy=TRUE)$estimate[1],3)
tabela[6,3]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(knn2nb(knearneigh(parcela_vivas, k=8)),style="W"),zero.policy=TRUE)$p.value,5)
#k neighbours - inverse of distance weights 
tabela[5,4]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listwdist(nb2listw(knn2nb(knearneigh(parcela_vivas, k=4)))$n,parcela_vivas,type="idw"),zero.policy=TRUE)$estimate[1],3)
tabela[5,5]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listwdist(nb2listw(knn2nb(knearneigh(parcela_vivas, k=4)))$n,parcela_vivas,type="idw"),zero.policy=TRUE)$p.value,5)
tabela[6,4]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listwdist(nb2listw(knn2nb(knearneigh(parcela_vivas, k=8)))$n,parcela_vivas,type="idw"),zero.policy=TRUE)$estimate[1],3)
tabela[6,5]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listwdist(nb2listw(knn2nb(knearneigh(parcela_vivas, k=8)))$n,parcela_vivas,type="idw"),zero.policy=TRUE)$p.value,5)
#k neighbours - binary weights
tabela[5,6]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(knn2nb(knearneigh(parcela_vivas, k=4)),style="B"),zero.policy=TRUE)$estimate[1],3)
tabela[5,7]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(knn2nb(knearneigh(parcela_vivas, k=4)),style="B"),zero.policy=TRUE)$p.value,5)
tabela[6,6]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(knn2nb(knearneigh(parcela_vivas, k=8)),style="B"),zero.policy=TRUE)$estimate[1],3)
tabela[6,7]<-round(moran.test(parcela_vivas$du_annual_growth,nb2listw(knn2nb(knearneigh(parcela_vivas, k=8)),style="B"),zero.policy=TRUE)$p.value,5)
#Area of influence neighbours - three weights (WW, Wdist, WB)
tabela[7,2]<-round(moran.test(parcela_vivas$du_annual_growth,WCW, zero.policy=TRUE)$estimate[1],3)
tabela[7,3]<-round(moran.test(parcela_vivas$du_annual_growth,WCW, zero.policy=TRUE)$p.value,5)
tabela[7,4]<-round(moran.test(parcela_vivas$du_annual_growth,WCdist, zero.policy=TRUE)$estimate[1],3)
tabela[7,5]<-round(moran.test(parcela_vivas$du_annual_growth,WCdist, zero.policy=TRUE)$p.value,5)
tabela[7,6]<-round(moran.test(parcela_vivas$du_annual_growth,WC, zero.policy=TRUE)$estimate[1],3)
tabela[7,7]<-round(moran.test(parcela_vivas$du_annual_growth,WC, zero.policy=TRUE)$p.value,5)
nomes<-c("Weights","Row-normalized","","Inverse Distance","", "Binary","");colnames(tabela)<-nomes
tabelaA<-tabela

#######
#Evaluation:
#Generally similar results on Moran I statistics on distance based and k-neighbours spatial matrices. 
#Area of influence method with distinct results, and depends on the plot
#Row-normalized and Binary weights produce same results on k-neighbours methods, as expected
#idw weights show consistent slightly higher Moran's I statistics, except for site C (?)
#8m distance base and k4 neighbours show slightly higher Moran's I statistics for any weights

########
##2.3 Correlogram
########
par(mfrow=c(2,3))
plot(sp.correlogram(knn2nb(knearneigh(parcela_vivas, k=4)), parcela_vivas$du_annual_growth, method="I" ,order=9,zero.policy=TRUE),ylim=c(0,0.35), main="k4 neighbours")
plot(sp.correlogram(knn2nb(knearneigh(parcela_vivas, k=8)), parcela_vivas$du_annual_growth, method="I" ,order=9,zero.policy=TRUE),ylim=c(0,0.35), main="k8 neighbours")
plot(sp.correlogram(dnearneigh(parcela_vivas, d1=0, d2=8), parcela_vivas$du_annual_growth, method="I" ,order=9,zero.policy=TRUE),ylim=c(0,0.35), main="dist 8m")
plot(sp.correlogram(dnearneigh(parcela_vivas, d1=0, d2=10), parcela_vivas$du_annual_growth, method="I" ,order=9,zero.policy=TRUE),ylim=c(0,0.35), main="dist 10m")
plot(sp.correlogram(dnearneigh(parcela_vivas, d1=0, d2=15), parcela_vivas$du_annual_growth, method="I" ,order=9,zero.policy=TRUE),ylim=c(0,0.35) ,main="dist 15m")
plot(sp.correlogram(W$neighbours, parcela_vivas$du_annual_growth, method="I" ,order=9,zero.policy=TRUE),ylim=c(0,0.35) ,main="Area of Influence")

#######
#Evaluation:
#Lower k neighbours or distance show highest error bars, values tend to stay similar in lags
#K-neighbours and distance approach tend to show similar results
#Area of influence approach produce distinct results. Its more difficult to explain the lag system with this nb object
#Checking Area of influence approach correlogram $cardnos argument show very variable number of neighbours

########
##2.4 Local Moran's I plot
########
#A plot can be created to check 1) the precision of the higher and lower clusters; 2) if they clusters are in accordance to field observations
#A plot is created for the six neighbours approaches used before

localm<-localmoran(parcela_vivas$du_annual_growth, listw=nb2listw(dnearneigh(parcela_vivas, d1=0, d2=8),zero.policy = TRUE,style="W"),alternative = "greater",zero.policy = TRUE)
localm<-localmoran(parcela_vivas$du_annual_growth, listw=nb2listw(dnearneigh(parcela_vivas, d1=0, d2=10),zero.policy = TRUE,style="W"),alternative = "greater",zero.policy = TRUE)
localm<-localmoran(parcela_vivas$du_annual_growth, listw=nb2listw(dnearneigh(parcela_vivas, d1=0, d2=15),zero.policy = TRUE,style="W"),alternative = "greater",zero.policy = TRUE)
localm<-localmoran(parcela_vivas$du_annual_growth, listw=nb2listw(knn2nb(knearneigh(parcela_vivas, k=4)),zero.policy = TRUE,style="W"),alternative = "greater",zero.policy = TRUE)
localm<-localmoran(parcela_vivas$du_annual_growth, listw=nb2listw(knn2nb(knearneigh(parcela_vivas, k=8)),zero.policy = TRUE,style="W"),alternative = "greater",zero.policy = TRUE)
localm<-localmoran(parcela_vivas$du_annual_growth, listw=WW,alternative = "greater")

#Prepare an object for the plot
local_plot<-parcela_vivas  
quadrant <- vector(mode = "numeric", length = nrow(localm)) #prepares a vector to receive a categorical value according to each quadrant
m.qualification <- local_plot$du_annual_growth - mean(local_plot$du_annual_growth) # centers the variable of interest around its mean
m.local <- localm[, "Ii"] - mean(na.omit(localm[, "Ii"])) # centers the local Moran's around the mean
signif <- 0.1# significance threshold - important for minimizing the outliers low-low and high-high  

# builds a data quadrant
quadrant[m.qualification > 0 & m.local > 0] <- 4 #high-high values
quadrant[m.qualification < 0 & m.local < 0] <- 1 #low-low values
quadrant[m.qualification < 0 & m.local > 0] <- 2 #low-high values
quadrant[m.qualification > 0 & m.local < 0] <- 3 #high-low values
quadrant[localm[, "Pr(z > 0)"] > signif] <- 0 #other values

# plot in r
brks <- c(0, 1, 2, 3, 4)
colors <- c("grey", "black", "orange", "red", "darkgreen")
plot(local_plot[1],  col = colors[findInterval(quadrant, brks, all.inside = FALSE)],  pch = c(1, 18, 16, 16, 16)[as.factor(quadrant)])
legend("bottomleft", legend = c("insignificant","low-low","low-high","high-low","high-high"),fill=colors,bty="n")

#######
#Evaluation:
#k-4 and 8m dist produces a plot with low focus in comparing to others. This is most relevant for plot A, where there is less spatial autocorrelation
#k-8, 10m, and 15m seem to produce intended clusters, with a tradeoff in precision/clusters size
#Area of influence approach fails at plotting realistic clusters

##################################################################################################################################
#### Spatial weights matrix selection according to results from neighbours network, correlogram, global moran's I and local moran's I.
#nb neighbours network --  k4, dist 8m, dist 15m and AIA were considered less adequate
#correlograms -- k4, dist 8m and AIA were considered less adequate        
#Global Moran's I test -- AIA was considered less adequate   
#Local Moran's I test -- k4, dist 8m and AIA were considered less adequate     

#Due to potentially being more accurate/balanced in describing the data, two spatial matrices will continue to the modelling phase: k-8 and dist 10m.


             
             
###############################
##3. Modelling
###############################
#Section 3 - Non-spatial and spatial modelling
#Non-spatial and spatial models will be fitted to each plot separately, and to all data, with the following steps: 
#1) Non-spatial linear modelling - Individual tree and tree group methods
#2) Spatial linear modelling; 

########
##3.1 Non-spatial modelling 
########
##3.3.1 Individual tree linear modelling
########                
X<-parcela_vivas
st_geometry(X)=NULL
f<-(du_annual_growth~Cea_0.5m_1px+Cea_1m_1px+Elev_1px+slope_1px+cos_aspect_1px+TRI_1px+TPI_1px+TWI_1px)

#Automatic stepwise selection of variables
mod<-(step(lm(f, data=X)))
summary(mod); 
vif(mod);
plot(mod)

#Manual selection of variables - add biological interpretation to variable selection
summary(lm(du_annual_growth~Cea_0.5m_1px+Cea_1m_1px+ TPI_tree_1px+TWI_tree_1px, data=X))

########
##3.3.2  Group linear modelling
######## 
###Two methods were tested for creat tree group units: 1) groups of k-8 neighbours (groups of 9 trees); 2) groups by intersection of tree in fixed area grids.



             
par<- parcela
xy = st_coordinates(par)
par = par[order(xy[,"X"], xy[,"Y"]),]

             




             
1.3.2
#######################################
#Considering du_mean response variable

##### Creating variables considering a moving window of the subject tree and the 8 closer neighbours (queen's case continuity)

#Remove lines with NA's in TRI/TPI, respective to points very close to the limits of the area and the 5x5 matrix from TRI is not completetly available
A <- A[!is.na(A$TRI_1px), ]  

#Calculation of du_mean and attribution of values to tree points

#Creating a dataframe for each subject tree and respective closest 8 neighbours (queen case)
valor_du_id <- data.frame(matrix(NA,  ncol = 39))
valor_du_1 <- data.frame(matrix(NA,  ncol = 39))
valor_du_2 <- data.frame(matrix(NA,  ncol = 39))
valor_du_3 <- data.frame(matrix(NA,  ncol = 39))
valor_du_4 <- data.frame(matrix(NA,  ncol = 39))
valor_du_5 <- data.frame(matrix(NA,  ncol = 39))
valor_du_6 <- data.frame(matrix(NA,  ncol = 39))
valor_du_7 <- data.frame(matrix(NA,  ncol = 39))
valor_du_8 <- data.frame(matrix(NA,  ncol = 39))

#Find each subject tree and respective closest 8 neighbours (queen case)
A$continId<-c(1:dim(A)[1])
for(i in c(1:nrow(A))) {
  valor_du_id[i,]<-A[i,]
  valor_du_1[i,]<-(A[which(A$continId == ((knearneigh(A, k=8)$nn[i]))),])
  valor_du_2[i,]<-(A[which(A$continId == ((knearneigh(A, k=8)$nn[i,2]))),])
  valor_du_3[i,]<-(A[which(A$continId == ((knearneigh(A, k=8)$nn[i,3]))),])
  valor_du_4[i,]<-(A[which(A$continId == ((knearneigh(A, k=8)$nn[i,4]))),])
  valor_du_5[i,]<-(A[which(A$continId == ((knearneigh(A, k=8)$nn[i,5]))),])
  valor_du_6[i,]<-(A[which(A$continId == ((knearneigh(A, k=8)$nn[i,6]))),])
  valor_du_7[i,]<-(A[which(A$continId == ((knearneigh(A, k=8)$nn[i,7]))),])
  valor_du_8[i,]<-(A[which(A$continId == ((knearneigh(A, k=8)$nn[i,8]))),])
}
head(valor_du_mixid)
colnames(valor_du_id)<-names(A)
colnames(valor_du_1)<-names(A)
colnames(valor_du_2)<-names(A)
colnames(valor_du_3)<-names(A)
colnames(valor_du_4)<-names(A)
colnames(valor_du_5)<-names(A)
colnames(valor_du_6)<-names(A)
colnames(valor_du_7)<-names(A)
colnames(valor_du_8)<-names(A)

#Calculate mean_du
names(A)
A$mean_du_mix<-((valor_du_id[,"du"]+valor_du_1[,"du"]+valor_du_2[,"du"]+valor_du_3[,"du"]+
                           valor_du_4[,"du"]+valor_du_5[,"du"]+valor_du_6[,"du"]+valor_du_7[,"du"]+
                           valor_du_8[,"du"])/9)
plot(A["mean_du_mix"], pch=16)

#Calculate values of terrain variables attributes to points
A$Cea_0.5_mix<-((valor_du_id[,"Cea_0.5m_1px"]+valor_du_1[,"Cea_0.5m_1px"]+valor_du_2[,"Cea_0.5m_1px"]+valor_du_3[,"Cea_0.5m_1px"]+  #Example of Cea_0.5
                           valor_du_4[,"Cea_0.5m_1px"]+valor_du_5[,"Cea_0.5m_1px"]+valor_du_6[,"Cea_0.5m_1px"]+valor_du_7[,"Cea_0.5m_1px"]+
                           valor_du_8[,"Cea_0.5m_1px"])/9)

#######################################
#From now on is required to consider two datasets, the original with full data; A2 where dead trees are removed
######################################
#Spatial autocorrelation analysis

A2<-A[which(A$Morta == 0),] ## Select on of the 4 properties (A, B, C, D)

#Definition of Spatial Matrix
#Selection of neighbours according to overlapping areas of influence

A2$du_dug<-""
A2$du_dug<-A2$du/(sqrt(sum((A2$du)^2)/length(A2$du)))
A2$du_dug<-as.numeric(A2$du_dug)
A2$influence_area_est<-2.5*(28.502*exp((-66.436+4.201*(A2$du_dug))/(19.817+A2$du))/2) 
plot(A2["influence_area_est"],pch=16)

xyA=st_coordinates(A2)
matrixA<-dist(xyA, "euclidean") #Calculas as distancias em classe dist
matrixA=as.matrix(matrixA, labels=TRUE) #Passa o objecto de classe dist para matriz
colnames(matrixA) <- rownames(matrixA) <- A2$continId
meltA <- melt(matrixA) #desfaz a matrix em colunas apenas
summary(meltA)

melt_0<-melt[which(meltA$value!=0),]  
submelt01<-meltA[melt_0$Var1 %in% M101$continId & melt_0$Var2 %in% A2$continId,]
submelt01<-submelt01[which(submelt01$value<33),]   #minimize the possible neighbours to run faster, where 33 is the max possible distance between tree overlapping areas of influence
submelt01<-submelt01[which(submelt01$value!=0),]
mt<-merge(submelt01, A2[,c("continId","influence_area_est" )], by.x="Var1", by.y="continId") #Criar uma coluna de diametros para a Var1, dependendo do numero da arvore
mtt<-merge(mt, M101[,c("continId","influence_area_est" )], by.x="Var2", by.y="continId")  #Criar uma coluna de diametros para a Var2, dependendo do numero da arvore
names(mtt)<-c(names(mtt)[1:3], "influence_area_est2",  "influence_area_est1") #mudar os nomes das colunas da novas da dataframe
head(mtt)
matrixA<-matrix(nrow=nrow(A2), ncol=nrow(A2))
for (k in c(1:nrow(mtt))){
  valor1<-mtt[k,1]
  valor2<-mtt[k,2]
  linha<- mtt[k,]
  #  matrixA[valor1,valor2]<- ifelse((linha$influence_area_est1 + linha$influence_area_est2 > linha$value),valor2,0)
  matrixA[valor1,valor2]<- ifelse((linha$influence_area_est1 + linha$influence_area_est2 > linha$value),1,0)
  }
matrixA[is.na(matrixA)] = 0
colnames(matrixA) <- rownames(matrixA) <- A2$continId
View(matrixA)
WA<- mat2listw(matrixA)
par(cex=0.5, pch=16)
plot(WA,coord=st_coordinates(A2), col="red")

#Global Moran's I test
moran.test(A2$du, listw=WA,zero.policy=TRUE)

#Correlogram construction and plotting 
 sp.correlogram(Wa, var=A2$du, method="I", order=8)

#Local Moran's I Analysis

  nlist <- knn2nb(knearneigh(A2,k=8))   #Neighbours are defined as the 8 closest neighbours, as it make more sense for local moran tests
  Wk8 <- nb2listw(A2,style="W")
  
  localm<-localmoran(A2$du, listw=Wk8,alternative = "greater")
  A2$localmoran2<-localm[,"Pr(z > 0)"]
  quadrant <- vector(mode="numeric",length=nrow(localm))
  m.qualification <- A2$du - mean(A2$du)  # centers the variable of interest around its mean
  m.local <- localm[,1] - mean(localm[,1])    # centers the local Moran's around the mean
  signif <- 0.1 # significance threshold
  quadrant[m.qualification >0 & m.local>0] <- 4  # builds a data quadrant
  quadrant[m.qualification <0 & m.local<0] <- 1      
  quadrant[m.qualification <0 & m.local>0] <- 2
  quadrant[m.qualification >0 & m.local<0] <- 3
  quadrant[A2$localmoran2>signif] <- 0   
  # plot 
  brks <- c(0,1,2,3,4)
  colors <- c("grey","black","orange","red","darkgreen")
  plot(A2[1],col=colors[findInterval(quadrant,brks,all.inside=FALSE)], pch=c(1,18,16,16,16)[as.factor(quadrant)],main="")
  legend("bottomleft", legend = c("insignificant","low-low","low-high","high-low","high-high"),
        fill=colors,bty="n")
       
#######################################
# Non-spatial modelling

X<-A
st_geometry(X)=NULL
summary(lm(f , data=X))
vif(lm(funcao, data=X))
plot(lm(funcao, data=X))
AIC(lm(funcao , data=X))
  
 f<-as.formula("du~  Cea_1m_1px+  Cea_0.5m_1px+  slope_1px+  Elev_1px+  TRI_1px+  TPI_1px+  cos_aspect_1px+  TWI_1px")        #function for linear models on individual tree diameter for singular sites
 f<-as.formula("du_annual_growth~ Cea_1_mean+  Cea_0.5_mean+  slope_mean+  Elev_mean+  TRI_mean+ cos_aspect_mean+ TWI_mean")  #function for linear models on individual tree diameter for all data
 f<-as.formula("du_mean~  Cea_1m_mean+  Cea_0.5m_1px+  slope_1px+  Elev_1px+  TRI_1px+  TPI_1px+  cos_aspect_1px+  TWI_1px")  #function for linear models on mean tree diameter for singular sites
 f<-as.formula("mean_du_annual_growth~ Cea_1_mean+  Cea_0.5_mean+  slope_mean+  Elev_mean+  TRI_mean+ cos_aspect_mean+ TWI_mean") #function for linear models on mean tree diameter for all data
 
#######################################
### Spatial modelling

duplicated(A$geometry)
 W <- nb2listw(WA$neighbours, style="W",zero.policy = TRUE)
 f <- as.formula("du~Cea_1m_1px+  Cea_0.5m_1px+  slope_1px+  Elev_1px+  TRI_1px+  TPI_1px+  cos_aspect_1px+  TWI_1px")

 
 mod.lag <- lagsarlm(f,data=A2,listw=Wa,zero.policy = TRUE)
 summary(mod.lag)
 
 mod.err <- errorsarlm(f,data=A2,listw=Wa,listw=W,zero.policy = TRUE)
 summary(mod.err)
 
 LR.sarlm(m,mod.lag)
 LR.sarlm(m,mod.err)
 AIC(mod.lag,mod.err)
 
 mod.sac <- sacsarlm(f,data=A2,listw=Wa,zero.policy = TRUE)
 LR.sarlm(mod.sac,mod.lag)
 LR.sarlm(mod.sac,mod.err)
 AIC(mod.lag,mod.err,mod.sac,n)
 summary(mod.sac)
 
 mod.sac2 <- sacsarlm(du ~ Cea_0.5m_1px+slope_1px+TRI_1px+TPI_1px+TWI_1px,data=A2,listw=W,zero.policy = TRUE) ##stepwise removal of variables by the user
 summary(mod.sac2)
 AIC(mod.lag,mod.err,mod.sac, mod.sac2)
 hist(mod.sac2$residuals)
 qqnorm(mod.sac2$residuals)
 qqline(mod.sac2$residuals)
 plot(mod.sac2$residuals ~ fitted(mod.sac2), data=A2)

 

